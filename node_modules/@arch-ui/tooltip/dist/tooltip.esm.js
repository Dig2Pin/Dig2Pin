import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import { jsx } from '@emotion/core';
import { useState, useRef, useEffect, Fragment } from 'react';
import { createPortal } from 'react-dom';
import flushable from 'flushable';
import styled from '@emotion/styled';
import { usePopper } from 'react-popper';
import { TransitionProvider, fade } from '@arch-ui/modal-utils';
import { colors, gridSize } from '@arch-ui/theme';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
// Styled Component
// ==============================

const TooltipElement = styled.div({
  backgroundColor: colors.N80,
  borderRadius: 3,
  color: 'white',
  fontSize: '0.75rem',
  fontWeight: 500,
  padding: "".concat(gridSize / 2, "px ").concat(gridSize, "px"),
  pointerEvents: 'none',
  // tooltips are non-interactive, they shouldn't get in the way of other elements
  zIndex: 2
});

const TooltipPositioner = ({
  targetNode,
  placement,
  style,
  className,
  children
}) => {
  const [popperElement, setPopperElement] = useState(null);
  const {
    styles
  } = usePopper(targetNode, popperElement, {
    placement,
    modifiers: [{
      name: 'hide',
      enabled: false
    }, {
      name: 'preventOverflow',
      enabled: false
    }]
  });
  return createPortal(jsx("div", {
    ref: setPopperElement,
    css: {
      zIndex: 2000
    },
    style: _objectSpread({}, style, {}, styles.popper)
  }, jsx("div", {
    css: {
      margin: gridSize
    }
  }, jsx(TooltipElement, {
    className: className
  }, children))), document.body);
}; // ==============================
// Stateful Component
// ==============================


const LISTENER_OPTIONS = {
  passive: true
};
let pendingHide;

const showTooltip = (fn, defaultDelay) => {
  const isHidePending = pendingHide && pendingHide.pending();

  if (isHidePending) {
    pendingHide.flush();
  }

  const pendingShow = flushable(fn, isHidePending ? 0 : defaultDelay);
  return pendingShow.cancel;
};

const hideTooltip = (fn, defaultDelay) => {
  pendingHide = flushable(fn, defaultDelay);
  return pendingHide.cancel;
};

const Tooltip = ({
  children,
  content,
  onHide,
  onShow,
  placement = 'bottom',
  className,
  hideOnMouseDown,
  hideOnKeyDown,
  delay = 300
}) => {
  const [isVisible, setIsVisible] = useState(false);
  const ref = useRef();
  useEffect(() => {
    const target = ref.current;

    if (!target) {
      throw new Error('You must pass the ref onto your target node.');
    }

    if (!target.nodeName) {
      throw new Error("It looks like you've passed the ref onto a component. You must pass the ref onto your target node.");
    }

    let cancelPendingSetState = () => {};

    const cancel = () => {
      cancelPendingSetState();
      setIsVisible(false);
    };

    const handleMouseEnter = () => {
      cancelPendingSetState();

      if (isVisible) {
        return;
      }

      if (hideOnMouseDown && target) {
        target.addEventListener('mousedown', cancel, LISTENER_OPTIONS);
      }

      if (hideOnKeyDown) {
        document.addEventListener('keydown', cancel, LISTENER_OPTIONS);
      }

      cancelPendingSetState = showTooltip(() => setIsVisible(true), delay);
    };

    const handleMouseLeave = () => {
      cancelPendingSetState();

      if (!isVisible) {
        return;
      }

      if (hideOnMouseDown && target) {
        target.removeEventListener('mousedown', cancel, LISTENER_OPTIONS);
      }

      if (hideOnKeyDown) {
        document.removeEventListener('keydown', cancel, LISTENER_OPTIONS);
      }

      cancelPendingSetState = hideTooltip(() => setIsVisible(false), delay);
    };

    target.addEventListener('mouseenter', handleMouseEnter, LISTENER_OPTIONS);
    target.addEventListener('mouseleave', handleMouseLeave, LISTENER_OPTIONS);
    return () => {
      cancelPendingSetState();

      if (target) {
        target.removeEventListener('mouseenter', handleMouseEnter, LISTENER_OPTIONS);
        target.removeEventListener('mouseleave', handleMouseLeave, LISTENER_OPTIONS);
      }
    };
  }, [isVisible]);
  return jsx(Fragment, null, children(ref), jsx(TransitionProvider, {
    isOpen: isVisible,
    onEntered: onShow,
    onExited: onHide
  }, transitionState => jsx(TooltipPositioner, {
    targetNode: ref.current,
    placement: placement,
    className: className,
    style: fade(transitionState)
  }, content)));
};

export default Tooltip;
