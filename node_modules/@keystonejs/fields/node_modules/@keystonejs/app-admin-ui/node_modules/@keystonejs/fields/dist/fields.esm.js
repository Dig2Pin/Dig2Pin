import { join as _join } from "path";
import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import inflection from 'inflection';
import { parseFieldAccess } from '@keystonejs/access-control';
import { formatISO, parseISO } from 'date-fns';
import { MongooseFieldAdapter } from '@keystonejs/adapter-mongoose';
import { KnexFieldAdapter } from '@keystonejs/adapter-knex';
import mongoose from 'mongoose';
import pluralize from 'pluralize';
import { Block } from '@keystonejs/field-content/Block';
import { imageContainer, caption } from '@keystonejs/field-content/blocks';
import groupBy from 'lodash.groupby';
import pSettle from 'p-settle';
import { pick, intersection } from '@keystonejs/utils';
import { createError } from 'apollo-errors';
import { GraphQLScalarType } from 'graphql';
import { Kind } from 'graphql/language';
import { DateTime, FixedOffsetZone } from 'luxon';
import fetch from 'node-fetch';
import dumbPasswords from 'dumb-passwords';
import slugify from '@sindresorhus/slugify';
import cuid from 'cuid';
import UnsplashAPI, { toJson } from 'unsplash-js';
import queryString from 'query-string';

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

class Field {
  constructor(path, _ref, {
    getListByKey,
    listKey,
    listAdapter,
    fieldAdapterClass,
    defaultAccess,
    schemaNames
  }) {
    let {
      hooks = {},
      isRequired,
      defaultValue,
      access,
      label,
      schemaDoc,
      adminDoc,
      adminConfig
    } = _ref,
        config = _objectWithoutProperties(_ref, ["hooks", "isRequired", "defaultValue", "access", "label", "schemaDoc", "adminDoc", "adminConfig"]);

    this.path = path;
    this.isPrimaryKey = path === 'id';
    this.schemaDoc = schemaDoc;
    this.adminDoc = adminDoc;
    this.adminConfig = adminConfig;
    this.config = config;
    this.isRequired = !!isRequired;
    this.defaultValue = defaultValue;
    this.isOrderable = false;
    this.hooks = hooks;
    this.getListByKey = getListByKey;
    this.listKey = listKey;
    this.label = label || inflection.humanize(inflection.underscore(path));
    this.adapter = listAdapter.newFieldAdapter(fieldAdapterClass, this.constructor.name, path, this, getListByKey, _objectSpread({}, config)); // Should be overwritten by types that implement a Relationship interface

    this.isRelationship = false;
    this.access = this.parseFieldAccess({
      schemaNames,
      listKey,
      fieldKey: path,
      defaultAccess,
      access
    });
  }

  parseFieldAccess(args) {
    return parseFieldAccess(args);
  } // Field types should replace this if they want to any fields to the output type


  gqlOutputFields() {
    return [];
  }

  gqlOutputFieldResolvers() {
    return {};
  }
  /**
   * Auxiliary Types are top-level types which a type may need or provide.
   * Example: the `File` type, adds a graphql auxiliary type of `FileUpload`, as
   * well as an `uploadFile()` graphql auxiliary type query resolver
   *
   * These are special cases, and should be used sparingly
   *
   * NOTE: When a naming conflict occurs, a list's types/queries/mutations will
   * overwrite any auxiliary types defined by an individual type.
   */


  getGqlAuxTypes() {
    return [];
  }

  gqlAuxFieldResolvers() {
    return {};
  }

  getGqlAuxQueries() {
    return [];
  }

  gqlAuxQueryResolvers() {
    return {};
  }

  getGqlAuxMutations() {
    return [];
  }

  gqlAuxMutationResolvers() {
    return {};
  }
  /**
   * @param {Object} data
   * @param {Object} data.resolvedData  The incoming item for the mutation with
   * relationships and defaults already resolved
   * @param {Object} data.existingItem If this is a updateX mutation, this will
   * be the existing data in the database
   * @param {Object} data.context The graphQL context object of the current
   * request
   * @param {Object} data.originalInput The raw incoming item from the mutation
   * (no relationships or defaults resolved)
   * @param {Object} data.actions
   * @param {Function} data.actions.query Perform a graphQl query
   * programmatically
   */


  async resolveInput({
    resolvedData
  }) {
    return resolvedData[this.path];
  }

  async validateInput() {}

  async beforeChange() {}

  async afterChange() {}

  async beforeDelete() {}

  async validateDelete() {}

  async afterDelete() {}

  gqlQueryInputFields() {
    return [];
  }

  equalityInputFields(type) {
    return [`${this.path}: ${type}`, `${this.path}_not: ${type}`];
  }

  equalityInputFieldsInsensitive(type) {
    return [`${this.path}_i: ${type}`, `${this.path}_not_i: ${type}`];
  }

  inInputFields(type) {
    return [`${this.path}_in: [${type}]`, `${this.path}_not_in: [${type}]`];
  }

  orderingInputFields(type) {
    return [`${this.path}_lt: ${type}`, `${this.path}_lte: ${type}`, `${this.path}_gt: ${type}`, `${this.path}_gte: ${type}`];
  }

  stringInputFields(type) {
    return [`${this.path}_contains: ${type}`, `${this.path}_not_contains: ${type}`, `${this.path}_starts_with: ${type}`, `${this.path}_not_starts_with: ${type}`, `${this.path}_ends_with: ${type}`, `${this.path}_not_ends_with: ${type}`];
  }

  stringInputFieldsInsensitive(type) {
    return [`${this.path}_contains_i: ${type}`, `${this.path}_not_contains_i: ${type}`, `${this.path}_starts_with_i: ${type}`, `${this.path}_not_starts_with_i: ${type}`, `${this.path}_ends_with_i: ${type}`, `${this.path}_not_ends_with_i: ${type}`];
  }

  get gqlCreateInputFields() {
    return [];
  }

  get gqlUpdateInputFields() {
    return [];
  }

  getAdminMeta({
    schemaName
  }) {
    const schemaAccess = this.access[schemaName];
    return this.extendAdminMeta(_objectSpread(_objectSpread({
      label: this.label,
      path: this.path,
      type: this.constructor.name,
      isRequired: this.isRequired,
      isOrderable: this.isOrderable,
      // We can only pass scalar default values through to the admin ui, not
      // functions
      defaultValue: typeof this.defaultValue !== 'function' ? this.defaultValue : undefined,
      isPrimaryKey: this.isPrimaryKey
    }, this.adminConfig), {}, {
      // NOTE: This data is serialised, so we're unable to pass through any
      // access control _functions_. But we can still check for the boolean case
      // and pass that through (we assume that if there is a function, it's a
      // "maybe" true, so default it to true).
      access: {
        create: !!schemaAccess.create,
        read: !!schemaAccess.read,
        update: !!schemaAccess.update
      },
      adminDoc: this.adminDoc
    }));
  }

  extendAdminMeta(meta) {
    return meta;
  }

  extendAdminViews(views) {
    return views;
  }

  getDefaultValue({
    context,
    originalInput,
    actions
  }) {
    if (typeof this.defaultValue !== 'undefined') {
      if (typeof this.defaultValue === 'function') {
        return this.defaultValue({
          context,
          originalInput,
          actions
        });
      } else {
        return this.defaultValue;
      }
    } // By default, the default value is undefined


    return undefined;
  }

}

function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$1(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

class CalendarDay extends Field {
  constructor(path, {
    format = 'yyyy-MM-dd',
    yearRangeFrom = new Date().getFullYear() - 100,
    yearRangeTo = new Date().getFullYear()
  }) {
    super(...arguments);
    this.format = format;
    this.yearRangeFrom = yearRangeFrom;
    this.yearRangeTo = yearRangeTo;
    this.isOrderable = true;
  }

  gqlOutputFields() {
    return [`${this.path}: String`];
  }

  gqlQueryInputFields() {
    return [...this.equalityInputFields('String'), ...this.orderingInputFields('String'), ...this.inInputFields('String')];
  }

  get gqlUpdateInputFields() {
    return [`${this.path}: String`];
  }

  get gqlCreateInputFields() {
    return [`${this.path}: String`];
  }

  extendAdminMeta(meta) {
    return _objectSpread$1(_objectSpread$1({}, meta), {}, {
      format: this.format,
      yearRangeFrom: this.yearRangeFrom,
      yearRangeTo: this.yearRangeTo
    });
  }

}

const CommonCalendarInterface = superclass => class extends superclass {
  getQueryConditions(dbPath) {
    return _objectSpread$1(_objectSpread$1(_objectSpread$1({}, this.equalityConditions(dbPath)), this.orderingConditions(dbPath)), this.inConditions(dbPath));
  }

};

class MongoCalendarDayInterface extends CommonCalendarInterface(MongooseFieldAdapter) {
  addToMongooseSchema(schema) {
    const validator = a => typeof a === 'string' && formatISO(parseISO(a), {
      representation: 'date'
    }) === a;

    const schemaOptions = {
      type: String,
      validate: {
        validator: this.buildValidator(validator),
        message: '{VALUE} is not an ISO8601 date string (yyyy-MM-dd)'
      }
    };
    schema.add({
      [this.path]: this.mergeSchemaOptions(schemaOptions, this.config)
    });
  }

}

class KnexCalendarDayInterface extends CommonCalendarInterface(KnexFieldAdapter) {
  constructor() {
    super(...arguments);
    this.isUnique = !!this.config.isUnique;
    this.isIndexed = !!this.config.isIndexed && !this.config.isUnique;
  }

  addToTableSchema(table) {
    const column = table.date(this.path);
    if (this.isUnique) column.unique();else if (this.isIndexed) column.index();
    if (this.isNotNullable) column.notNullable();
    if (this.defaultTo) column.defaultTo(this.defaultTo);
  }

  setupHooks({
    addPostReadHook
  }) {
    addPostReadHook(item => {
      if (item[this.path]) {
        item[this.path] = formatISO(item[this.path], {
          representation: 'date'
        });
      }

      return item;
    });
  }

}

var index = {
  type: 'CalendarDay',
  implementation: CalendarDay,
  views: {
    Controller: _join(__dirname, "lyydfj"),
    Field: _join(__dirname, "ylvj83"),
    Filter: _join(__dirname, "153uqzr"),
    Cell: _join(__dirname, "g59l7t")
  },
  adapters: {
    mongoose: MongoCalendarDayInterface,
    knex: KnexCalendarDayInterface
  }
};

class Checkbox extends Field {
  constructor() {
    super(...arguments);
    this.isOrderable = true;
  }

  gqlOutputFields() {
    return [`${this.path}: Boolean`];
  }

  gqlOutputFieldResolvers() {
    return {
      [`${this.path}`]: item => item[this.path]
    };
  }

  gqlQueryInputFields() {
    return this.equalityInputFields('Boolean');
  }

  get gqlUpdateInputFields() {
    return [`${this.path}: Boolean`];
  }

  get gqlCreateInputFields() {
    return [`${this.path}: Boolean`];
  }

}

class MongoCheckboxInterface extends MongooseFieldAdapter {
  addToMongooseSchema(schema) {
    schema.add({
      [this.path]: this.mergeSchemaOptions({
        type: Boolean
      }, this.config)
    });
  }

  getQueryConditions(dbPath) {
    return this.equalityConditions(dbPath);
  }

}

class KnexCheckboxInterface extends KnexFieldAdapter {
  constructor() {
    super(...arguments); // Error rather than ignoring invalid config

    if (this.config.isUnique || this.config.isIndexed) {
      throw `The Checkbox field type doesn't support indexes on Knex. ` + `Check the config for ${this.path} on the ${this.field.listKey} list`;
    }
  }

  addToTableSchema(table) {
    const column = table.boolean(this.path);
    if (this.isNotNullable) column.notNullable();
    if (typeof this.defaultTo !== 'undefined') column.defaultTo(this.defaultTo);
  }

  getQueryConditions(dbPath) {
    return this.equalityConditions(dbPath);
  }

}

var index$1 = {
  type: 'Checkbox',
  implementation: Checkbox,
  views: {
    Controller: _join(__dirname, "rklrac"),
    Field: _join(__dirname, "ore4pa"),
    Filter: _join(__dirname, "nh8nsp"),
    Cell: _join(__dirname, "1v516tp")
  },
  adapters: {
    mongoose: MongoCheckboxInterface,
    knex: KnexCheckboxInterface
  }
};

function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$2(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
} // https://mongoosejs.com/docs/migrating_to_5.html#id-getter


mongoose.set('objectIdGetter', false);
const {
  Types: {
    ObjectId
  }
} = mongoose;

class File extends Field {
  constructor(path, {
    adapter
  }) {
    super(...arguments);
    this.graphQLOutputType = 'File';
    this.fileAdapter = adapter;

    if (!this.fileAdapter) {
      throw new Error(`No file adapter provided for File field.`);
    }
  }

  gqlOutputFields() {
    return [`${this.path}: ${this.graphQLOutputType}`];
  }

  extendAdminMeta(meta) {
    return _objectSpread$2({}, meta);
  }

  gqlQueryInputFields() {
    return [...this.equalityInputFields('String'), ...this.stringInputFields('String'), ...this.inInputFields('String')];
  }

  getFileUploadType() {
    return 'Upload';
  }

  getGqlAuxTypes() {
    return [`
      type ${this.graphQLOutputType} {
        id: ID
        path: String
        filename: String
        originalFilename: String
        mimetype: String
        encoding: String
        publicUrl: String
      }
    `];
  } // Called on `User.avatar` for example


  gqlOutputFieldResolvers() {
    return {
      [this.path]: item => {
        const itemValues = item[this.path];

        if (!itemValues) {
          return null;
        } // FIXME: This can hopefully be removed once graphql 14.1.0 is released.
        // https://github.com/graphql/graphql-js/pull/1520


        if (itemValues.id) itemValues.id = itemValues.id.toString();
        return _objectSpread$2({
          publicUrl: this.fileAdapter.publicUrl(itemValues)
        }, itemValues);
      }
    };
  }

  async resolveInput({
    resolvedData,
    existingItem
  }) {
    const previousData = existingItem && existingItem[this.path];
    const uploadData = resolvedData[this.path]; // NOTE: The following two conditions could easily be combined into a
    // single `if (!uploadData) return uploadData`, but that would lose the
    // nuance of returning `undefined` vs `null`.
    // Premature Optimisers; be ware!

    if (typeof uploadData === 'undefined') {
      // Nothing was passed in, so we can bail early.
      return undefined;
    }

    if (uploadData === null) {
      // `null` was specifically uploaded, and we should set the field value to
      // null. To do that we... return `null`
      return null;
    }

    const {
      createReadStream,
      filename: originalFilename,
      mimetype,
      encoding
    } = await uploadData;
    const stream = createReadStream();

    if (!stream && previousData) {
      // TODO: FIXME: Handle when stream is null. Can happen when:
      // Updating some other part of the item, but not the file (gets null
      // because no File DOM element is uploaded)
      return previousData;
    }

    const newId = new ObjectId();
    const {
      id,
      filename,
      _meta
    } = await this.fileAdapter.save({
      stream,
      filename: originalFilename,
      mimetype,
      encoding,
      id: newId
    });
    return {
      id,
      filename,
      originalFilename,
      mimetype,
      encoding,
      _meta
    };
  }

  get gqlUpdateInputFields() {
    return [`${this.path}: ${this.getFileUploadType()}`];
  }

  get gqlCreateInputFields() {
    return [`${this.path}: ${this.getFileUploadType()}`];
  }

}

const CommonFileInterface = superclass => class extends superclass {
  getQueryConditions(dbPath) {
    return _objectSpread$2(_objectSpread$2(_objectSpread$2({}, this.equalityConditions(dbPath)), this.stringConditions(dbPath)), this.inConditions(dbPath));
  }

};

class MongoFileInterface extends CommonFileInterface(MongooseFieldAdapter) {
  addToMongooseSchema(schema) {
    const schemaOptions = {
      type: {
        id: ObjectId,
        path: String,
        filename: String,
        originalFilename: String,
        mimetype: String,
        encoding: String,
        _meta: Object
      }
    };
    schema.add({
      [this.path]: this.mergeSchemaOptions(schemaOptions, this.config)
    });
  }

}

class KnexFileInterface extends CommonFileInterface(KnexFieldAdapter) {
  constructor() {
    super(...arguments); // Error rather than ignoring invalid config
    // We totally can index these values, it's just not trivial. See issue #1297

    if (this.config.isUnique || this.config.isIndexed) {
      throw `The File field type doesn't support indexes on Knex. ` + `Check the config for ${this.path} on the ${this.field.listKey} list`;
    }
  }

  addToTableSchema(table) {
    const column = table.jsonb(this.path);
    if (this.isNotNullable) column.notNullable();
    if (this.defaultTo) column.defaultTo(this.defaultTo);
  }

}

function ownKeys$3(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$3(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$3(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

class CloudinaryImage extends File {
  constructor() {
    super(...arguments);
    this.graphQLOutputType = 'CloudinaryImage_File';
  }

  gqlOutputFields() {
    return [`${this.path}: ${this.graphQLOutputType}`];
  }

  extendAdminMeta(meta) {
    // Overwrite so we have only the original meta
    return meta;
  }

  getFileUploadType() {
    return 'Upload';
  }

  getGqlAuxTypes({
    schemaName
  }) {
    return [...super.getGqlAuxTypes({
      schemaName
    }), `
      """Mirrors the formatting options [Cloudinary provides](https://cloudinary.com/documentation/image_transformation_reference).
      All options are strings as they ultimately end up in a URL."""
      input CloudinaryImageFormat {
        # Rewrites the filename to be this pretty string. Do not include '/' or '.'
        prettyName: String
        width: String
        height: String
        crop: String
        aspect_ratio: String
        gravity: String
        zoom: String
        x: String
        y: String
        format: String
        fetch_format: String
        quality: String
        radius: String
        angle: String
        effect: String
        opacity: String
        border: String
        background: String
        overlay: String
        underlay: String
        default_image: String
        delay: String
        color: String
        color_space: String
        dpr: String
        page: String
        density: String
        flags: String
        transformation: String
      }`, `extend type ${this.graphQLOutputType} {
        publicUrlTransformed(transformation: CloudinaryImageFormat): String
      }`];
  } // Called on `User.avatar` for example


  gqlOutputFieldResolvers() {
    return {
      [this.path]: item => {
        const itemValues = item[this.path];

        if (!itemValues) {
          return null;
        } // FIXME: This can hopefully be removed once graphql 14.1.0 is released.
        // https://github.com/graphql/graphql-js/pull/1520


        if (itemValues.id) itemValues.id = itemValues.id.toString();
        return _objectSpread$3({
          publicUrl: this.fileAdapter.publicUrl(itemValues),
          publicUrlTransformed: ({
            transformation
          }) => this.fileAdapter.publicUrlTransformed(itemValues, transformation)
        }, itemValues);
      }
    };
  }

}

function ownKeys$4(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$4(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$4(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function initOptions(options) {
  let optionsArray = options;
  if (typeof options === 'string') optionsArray = options.split(/\,\s*/);
  if (!Array.isArray(optionsArray)) return null;
  return optionsArray.map(i => {
    return typeof i === 'string' ? {
      value: i,
      label: inflection.humanize(i)
    } : i;
  });
}

const VALID_DATA_TYPES = ['enum', 'string', 'integer'];
const DOCS_URL = 'https://keystonejs.com/keystonejs/fields/src/types/select/';

function validateOptions({
  options,
  dataType,
  listKey,
  path
}) {
  if (!VALID_DATA_TYPES.includes(dataType)) {
    throw new Error(`
🚫 The select field ${listKey}.${path} is not configured with a valid data type;
📖 see ${DOCS_URL}
`);
  }

  options.forEach((option, i) => {
    if (dataType === 'enum') {
      if (!/^[a-zA-Z]\w*$/.test(option.value)) {
        throw new Error(`
🚫 The select field ${listKey}.${path} contains an invalid enum value ("${option.value}") in option ${i}
👉 You may want to use the "string" dataType
📖 see ${DOCS_URL}
`);
      }
    } else if (dataType === 'string') {
      if (typeof option.value !== 'string') {
        const integerHint = typeof option.value === 'number' ? `
👉 Did you mean to use the the "integer" dataType?` : '';
        throw new Error(`
🚫 The select field ${listKey}.${path} contains an invalid value (type ${typeof option.value}) in option ${i}${integerHint}
📖 see ${DOCS_URL}
`);
      }
    } else if (dataType === 'integer') {
      if (!Number.isInteger(option.value)) {
        throw new Error(`
🚫 The select field ${listKey}.${path} contains an invalid integer value ("${option.value}") in option ${i}
📖 see ${DOCS_URL}
`);
      }
    }
  });
}

class Select extends Field {
  constructor(path, {
    options,
    dataType = 'enum'
  }) {
    super(...arguments);
    this.options = initOptions(options);
    validateOptions({
      options: this.options,
      dataType,
      listKey: this.listKey,
      path
    });
    this.dataType = dataType;
    this.isOrderable = true;
  }

  gqlOutputFields() {
    return [`${this.path}: ${this.getTypeName()}`];
  }

  gqlOutputFieldResolvers() {
    return {
      [`${this.path}`]: item => item[this.path]
    };
  }

  getTypeName() {
    if (this.dataType === 'enum') {
      return `${this.listKey}${inflection.classify(this.path)}Type`;
    } else if (this.dataType === 'integer') {
      return 'Int';
    } else {
      return 'String';
    }
  }

  getGqlAuxTypes() {
    return this.dataType === 'enum' ? [`
      enum ${this.getTypeName()} {
        ${this.options.map(i => i.value).join('\n        ')}
      }
    `] : [];
  }

  extendAdminMeta(meta) {
    const {
      options,
      dataType
    } = this;
    return _objectSpread$4(_objectSpread$4({}, meta), {}, {
      options,
      dataType
    });
  }

  gqlQueryInputFields() {
    // TODO: This could be extended for Int type options with numeric filters
    return [...this.equalityInputFields(this.getTypeName()), ...this.inInputFields(this.getTypeName())];
  }

  get gqlUpdateInputFields() {
    return [`${this.path}: ${this.getTypeName()}`];
  }

  get gqlCreateInputFields() {
    return [`${this.path}: ${this.getTypeName()}`];
  }

}

const CommonSelectInterface = superclass => class extends superclass {
  getQueryConditions(dbPath) {
    return _objectSpread$4(_objectSpread$4({}, this.equalityConditions(dbPath)), this.inConditions(dbPath));
  }

};

class MongoSelectInterface extends CommonSelectInterface(MongooseFieldAdapter) {
  addToMongooseSchema(schema) {
    const options = this.field.dataType === 'integer' ? {
      type: Number
    } : {
      type: String,
      enum: [...this.field.options.map(i => i.value), null]
    };
    schema.add({
      [this.path]: this.mergeSchemaOptions(options, this.config)
    });
  }

}

class KnexSelectInterface extends CommonSelectInterface(KnexFieldAdapter) {
  constructor() {
    super(...arguments);
    this.isUnique = !!this.config.isUnique;
    this.isIndexed = !!this.config.isIndexed && !this.config.isUnique;
  }

  addToTableSchema(table) {
    let column;

    if (this.field.dataType === 'enum') {
      column = table.enu(this.path, this.field.options.map(({
        value
      }) => value));
    } else if (this.field.dataType === 'integer') {
      column = table.integer(this.path);
    } else {
      column = table.text(this.path);
    }

    if (this.isUnique) column.unique();else if (this.isIndexed) column.index();
    if (this.isNotNullable) column.notNullable();
    if (typeof this.defaultTo !== 'undefined') column.defaultTo(this.defaultTo);
  }

}

var SelectType = {
  type: 'Select',
  implementation: Select,
  views: {
    Controller: _join(__dirname, "agsrum"),
    Field: _join(__dirname, "s67gr7"),
    Filter: _join(__dirname, "mtwbac"),
    Cell: _join(__dirname, "1u1co9j")
  },
  adapters: {
    mongoose: MongoSelectInterface,
    knex: KnexSelectInterface
  }
};
const ParameterError = createError('ParameterError', {
  message: 'Incorrect parameters supplied',
  options: {
    showPath: true
  }
});

function ownKeys$5(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$5(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$5(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const NESTED_MUTATIONS = ['create', 'connect', 'disconnect', 'disconnectAll'];
/*** Input validation  ***/

const throwWithErrors = (message, meta) => {
  const error = new Error(message);
  throw Object.assign(error, meta);
};

function validateInput({
  input,
  target,
  many
}) {
  // Only accept mutations which we know how to handle.
  let validInputMutations = intersection(Object.keys(input), NESTED_MUTATIONS); // Filter out mutations which don't have any parameters

  if (many) {
    // to-many must have an array of objects
    validInputMutations = validInputMutations.filter(mutation => mutation === 'disconnectAll' || Array.isArray(input[mutation]));
  } else {
    validInputMutations = validInputMutations.filter(mutation => mutation === 'disconnectAll' || Object.keys(input[mutation]).length);
  } // We must have at least one valid mutation


  if (!validInputMutations.length) {
    throw new ParameterError({
      message: `Must provide a nested mutation (${NESTED_MUTATIONS.join(', ')}) when mutating ${target}`
    });
  } // For a non-many relationship we can't create AND connect - only one can be set at a time


  if (!many && validInputMutations.includes('create') && validInputMutations.includes('connect')) {
    throw new ParameterError({
      message: `Can only provide one of 'connect' or 'create' when mutating ${target}`
    });
  }

  return validInputMutations;
}

const cleanAndValidateInput = ({
  input,
  many,
  localField,
  target
}) => {
  try {
    return pick(input, validateInput({
      input,
      target,
      many
    }));
  } catch (error) {
    const message = `Nested mutation operation invalid for ${target}`;
    error.path = ['<validate>'];
    throwWithErrors(message, {
      errors: [error],
      path: [localField.path]
    });
  }
};

const _runActions = async (action, targets, path) => {
  const results = await pSettle((targets || []).map(action));
  const errors = results.map((settleInfo, index) => _objectSpread$5(_objectSpread$5({}, settleInfo), {}, {
    index
  })).filter(({
    isRejected
  }) => isRejected).map(({
    reason,
    index
  }) => {
    reason.path = [...path, index];
    return reason;
  }); // If there are no errors we know everything resolved successfully

  return [errors.length ? [] : results.map(({
    value
  }) => value), errors];
};

async function resolveNestedMany({
  input,
  currentValue,
  refList,
  context,
  localField,
  target,
  mutationState
}) {
  // Disconnections
  let disconnectIds = [];

  if (input.disconnectAll) {
    disconnectIds = [...currentValue];
  } else if (input.disconnect) {
    // We want to avoid DB lookups where possible, so we split the input into
    // two halves; one with ids, and the other without ids
    const {
      withId,
      withoutId
    } = groupBy(input.disconnect, ({
      id
    }) => id ? 'withId' : 'withoutId'); // We set the Ids we do find immediately

    disconnectIds = (withId || []).map(({
      id
    }) => id); // And any without ids (ie; other unique criteria), have to be looked up
    // This will resolve access control, etc for us.
    // In the future, when WhereUniqueInput accepts more than just an id,
    // this will also resolve those queries for us too.

    const action = where => refList.itemQuery(where, context, refList.gqlNames.itemQueryName); // We don't throw if any fail; we're only interested in the ones this user has
    // access to read (and hence remove from the list)


    const disconnectItems = (await pSettle((withoutId || []).map(action))).filter(({
      isFulfilled
    }) => isFulfilled).map(({
      value
    }) => value).filter(itemToDisconnect => itemToDisconnect); // Possible to get null results when the id doesn't exist, or read access is denied

    disconnectIds.push(...disconnectItems.map(({
      id
    }) => id));
  } // Connections


  let connectedIds = [];
  let createdIds = [];

  if (input.connect || input.create) {
    // This will resolve access control, etc for us.
    // In the future, when WhereUniqueInput accepts more than just an id,
    // this will also resolve those queries for us too.
    const [connectedItems, connectErrors] = await _runActions(where => refList.itemQuery({
      where
    }, context, refList.gqlNames.itemQueryName), input.connect, ['connect']); // Create related item. Will check for access control itself, no need to do anything extra here.
    // NOTE: We don't check for read access control on the returned ids as the
    // user will not have seen it, so it's ok to return it directly here.

    const [createdItems, createErrors] = await _runActions(data => refList.createMutation(data, context, mutationState), input.create, ['create']);
    const allErrors = [...connectErrors, ...createErrors];

    if (allErrors.length) {
      const message = `Unable to create and/or connect ${allErrors.length} ${target}`;
      throwWithErrors(message, {
        errors: allErrors,
        path: [localField.path]
      });
    }

    connectedIds = connectedItems.map(item => {
      if (item && item.id) {
        return item.id;
      } // Possible to get null results when the id doesn't exist, or read access is denied


      return null;
    });
    createdIds = createdItems.map(item => {
      if (item && item.id) {
        return item.id;
      } // Possible to get null results when the id doesn't exist, or read access is denied


      return null;
    });
  }

  return {
    disconnect: disconnectIds,
    connect: connectedIds,
    create: createdIds
  };
}

async function resolveNestedSingle({
  input,
  currentValue,
  localField,
  refList,
  context,
  target,
  mutationState
}) {
  let result_ = {};

  if ((input.disconnect || input.disconnectAll) && currentValue) {
    let idToDisconnect;

    if (input.disconnectAll) {
      idToDisconnect = currentValue;
    } else if (input.disconnect.id) {
      idToDisconnect = input.disconnect.id;
    } else {
      try {
        // Support other unique fields for disconnection
        idToDisconnect = (await refList.itemQuery({
          where: input.disconnect
        }, context, refList.gqlNames.itemQueryName)).id.toString();
      } catch (error) {// Maybe we don't have read access, or maybe the item doesn't exist
        // (recently deleted, or it's an erroneous value in the relationship field)
        // So we silently ignore it
      }
    }

    if (currentValue === idToDisconnect) {
      // Found the item, so unset it
      result_.disconnect = [idToDisconnect];
    }
  }

  let operation;
  let method;

  if (input.connect) {
    operation = 'connect';

    method = () => refList.itemQuery({
      where: input.connect
    }, context, refList.gqlNames.itemQueryName);
  } else if (input.create) {
    operation = 'create';

    method = () => refList.createMutation(input.create, context, mutationState);
  }

  if (operation) {
    // override result with the connected/created value
    // input is of type *RelateToOneInput
    let item;

    try {
      item = await method();
    } catch (error) {
      const message = `Unable to ${operation} a ${target}`;
      error.path = [operation];
      throwWithErrors(message, {
        errors: [error],
        path: [localField.path]
      });
    } // Might not exist if the input id doesn't exist / the user doesn't have read access


    if (item) {
      result_[operation] = [item.id];
    }
  }

  return result_;
}
/*
 * Resolve the nested mutations and return the ids of items to be connected/disconnected
 *
 * Returns: { connect: [id], disconnect: [id]}
 */


async function resolveNested({
  input,
  currentValue,
  many,
  listInfo,
  context,
  mutationState
}) {
  const localList = listInfo.local.list;
  const localField = listInfo.local.field;
  const refList = listInfo.foreign.list;
  const target = `${localList.key}.${localField.path}<${refList.key}>`;
  const args = {
    currentValue,
    refList,
    input: cleanAndValidateInput({
      input,
      many,
      localField,
      target
    }),
    context,
    localField,
    target,
    mutationState
  };
  return await (many ? resolveNestedMany(args) : resolveNestedSingle(args));
}

function ownKeys$6(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$6(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$6(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$6(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const {
  Schema: {
    Types: {
      ObjectId: ObjectId$1
    }
  }
} = mongoose;

class Relationship extends Field {
  constructor(path, {
    ref,
    many,
    withMeta
  }) {
    super(...arguments); // JM: It bugs me this is duplicated in the field adapters but initialisation order makes it hard to avoid

    const [refListKey, refFieldPath] = ref.split('.');
    this.refListKey = refListKey;
    this.refFieldPath = refFieldPath;
    this.isOrderable = true;
    this.isRelationship = true;
    this.many = many;
    this.withMeta = typeof withMeta !== 'undefined' ? withMeta : true;
  }

  tryResolveRefList() {
    const {
      listKey,
      path,
      refListKey,
      refFieldPath
    } = this;
    const refList = this.getListByKey(refListKey);

    if (!refList) {
      throw new Error(`Unable to resolve related list '${refListKey}' from ${listKey}.${path}`);
    }

    let refField;

    if (refFieldPath) {
      refField = refList.getFieldByPath(refFieldPath);

      if (!refField) {
        throw new Error(`Unable to resolve two way relationship field '${refListKey}.${refFieldPath}' from ${listKey}.${path}`);
      }
    }

    return {
      refList,
      refField
    };
  }

  gqlOutputFields({
    schemaName
  }) {
    const {
      refList
    } = this.tryResolveRefList();

    if (!refList.access[schemaName].read) {
      // It's not accessible in any way, so we can't expose the related field
      return [];
    }

    if (this.many) {
      const filterArgs = refList.getGraphqlFilterFragment().join('\n');
      return [`${this.path}(${filterArgs}): [${refList.gqlNames.outputTypeName}]`, this.withMeta ? `_${this.path}Meta(${filterArgs}): _QueryMeta` : ''];
    }

    return [`${this.path}: ${refList.gqlNames.outputTypeName}`];
  }

  extendAdminMeta(meta) {
    const {
      refListKey: ref,
      refFieldPath,
      many
    } = this;
    return _objectSpread$6(_objectSpread$6({}, meta), {}, {
      ref,
      refFieldPath,
      many
    });
  }

  gqlQueryInputFields({
    schemaName
  }) {
    const {
      refList
    } = this.tryResolveRefList();

    if (!refList.access[schemaName].read) {
      // It's not accessible in any way, so we can't expose the related field
      return [];
    }

    if (this.many) {
      return [`""" condition must be true for all nodes """
        ${this.path}_every: ${refList.gqlNames.whereInputName}`, `""" condition must be true for at least 1 node """
        ${this.path}_some: ${refList.gqlNames.whereInputName}`, `""" condition must be false for all nodes """
        ${this.path}_none: ${refList.gqlNames.whereInputName}`, `""" is the relation field null """
        ${this.path}_is_null: Boolean`];
    } else {
      return [`${this.path}: ${refList.gqlNames.whereInputName}`, `${this.path}_is_null: Boolean`];
    }
  }

  gqlOutputFieldResolvers({
    schemaName
  }) {
    const {
      refList
    } = this.tryResolveRefList();

    if (!refList.access[schemaName].read) {
      // It's not accessible in any way, so we can't expose the related field
      return [];
    } // to-one relationships are much easier to deal with.


    if (!this.many) {
      return {
        [this.path]: (item, _, context, info) => {
          // No ID set, so we return null for the value
          if (!item[this.path]) {
            return null;
          }

          const filteredQueryArgs = {
            where: {
              id: item[this.path].toString()
            }
          }; // We do a full query to ensure things like access control are applied

          return refList.listQuery(filteredQueryArgs, context, refList.gqlNames.listQueryName, info).then(items => items && items.length ? items[0] : null);
        }
      };
    }

    return _objectSpread$6({
      [this.path]: (item, args, context, info) => {
        return refList.listQuery(args, context, info.fieldName, info, {
          fromList: this.getListByKey(this.listKey),
          fromId: item.id,
          fromField: this.path
        });
      }
    }, this.withMeta && {
      [`_${this.path}Meta`]: (item, args, context, info) => {
        return refList.listQueryMeta(args, context, info.fieldName, info, {
          fromList: this.getListByKey(this.listKey),
          fromId: item.id,
          fromField: this.path
        });
      }
    });
  }
  /**
   * @param operations {Object}
   * {
   *   disconnectAll?: Boolean, (default: false),
   *   disconnect?: Array<where>, (default: []),
   *   connect?: Array<where>, (default: []),
   *   create?: Array<data>, (default: []),
   * }
   * NOTE: If `disconnectAll` is `true`, `disconnect` is ignored.
   * `where` is a WhereUniqueInput (eg; { id: "abc123" })
   * `data` is an input of the type expected for the ref list (eg; { data: { name: "Sarah" } })
   *
   * @return {Object}
   * {
   *   disconnect: Array<ID>,
   *   connect: Array<ID>,
   *   create: Array<ID>,
   * }
   * The indexes within the return arrays are guaranteed to match the indexes as
   * passed in `operations`.
   * Due to Access Control, it is possible thata some operations result in a
   * value of `null`. Be sure to guard against this in your code.
   * NOTE: If `disconnectAll` is true, `disconnect` will be an array of all
   * previous stored values, which means indecies may not match those passed in
   * `operations`.
   */


  async resolveNestedOperations(operations, item, context, getItem, mutationState) {
    const {
      refList,
      refField
    } = this.tryResolveRefList();
    const listInfo = {
      local: {
        list: this.getListByKey(this.listKey),
        field: this
      },
      foreign: {
        list: refList,
        field: refField
      }
    }; // Possible early out for null'd field
    // prettier-ignore

    if (!operations && ( // If the field is not required, and the value is `null`, we can ignore
    // it and move on.
    !this.isRequired // This field will be backlinked to this field's containing item, so we
    // can safely ignore it now expecing the backlinking process in the
    // calling code to take care of it.
    || refField && this.getListByKey(refField.refListKey) === listInfo.local.list)) {
      // Don't release the zalgo; always return a promise.
      return Promise.resolve({
        create: [],
        connect: [],
        disconnect: []
      });
    }

    let currentValue;

    if (this.many) {
      const info = {
        fieldName: this.path
      };
      currentValue = item ? await refList.listQuery({}, _objectSpread$6(_objectSpread$6({}, context), {}, {
        getListAccessControlForUser: () => true
      }), info.fieldName, info, {
        fromList: this.getListByKey(this.listKey),
        fromId: item.id,
        fromField: this.path
      }) : [];
      currentValue = currentValue.map(({
        id
      }) => id.toString());
    } else {
      currentValue = item && item[this.path];
      currentValue = currentValue && currentValue.toString();
    } // Collect the IDs to be connected and disconnected. This step may trigger
    // createMutation calls in order to obtain these IDs if required.


    const {
      create = [],
      connect = [],
      disconnect = []
    } = await resolveNested({
      input: operations,
      currentValue,
      listInfo,
      many: this.many,
      context,
      mutationState
    });
    return {
      create,
      connect,
      disconnect,
      currentValue
    };
  }

  getGqlAuxTypes({
    schemaName
  }) {
    const {
      refList
    } = this.tryResolveRefList();

    if (!refList.access[schemaName].update) {
      return [];
    } // We need an input type that is specific to creating nested items when
    // creating a relationship, ie;
    //
    // eg: Creating a new post at the same time as a new user
    // mutation createUser() {
    //   posts: [{ create: { title: 'Foobar' } }]
    // }
    //
    // Or, the inverse: Creating a new user at the same time as a new post
    // mutation createPost() {
    //   author: { create: { email: 'eg@example.com' } }
    // }
    //
    // Then there's the linking to existing records usecase:
    // mutation createPost() {
    //   author: { connect: { id: 'abc123' } }
    // }


    if (this.many) {
      return [`
        input ${refList.gqlNames.relateToManyInputName} {
          # Provide data to create a set of new ${refList.key}. Will also connect.
          create: [${refList.gqlNames.createInputName}]

          # Provide a filter to link to a set of existing ${refList.key}.
          connect: [${refList.gqlNames.whereUniqueInputName}]

          # Provide a filter to remove to a set of existing ${refList.key}.
          disconnect: [${refList.gqlNames.whereUniqueInputName}]

          # Remove all ${refList.key} in this list.
          disconnectAll: Boolean
        }
      `];
    }

    return [`
      input ${refList.gqlNames.relateToOneInputName} {
        # Provide data to create a new ${refList.key}.
        create: ${refList.gqlNames.createInputName}

        # Provide a filter to link to an existing ${refList.key}.
        connect: ${refList.gqlNames.whereUniqueInputName}

        # Provide a filter to remove to an existing ${refList.key}.
        disconnect: ${refList.gqlNames.whereUniqueInputName}

        # Remove the existing ${refList.key} (if any).
        disconnectAll: Boolean
      }
    `];
  }

  get gqlUpdateInputFields() {
    const {
      refList
    } = this.tryResolveRefList();

    if (this.many) {
      return [`${this.path}: ${refList.gqlNames.relateToManyInputName}`];
    }

    return [`${this.path}: ${refList.gqlNames.relateToOneInputName}`];
  }

  get gqlCreateInputFields() {
    return this.gqlUpdateInputFields;
  }

}

class MongoRelationshipInterface extends MongooseFieldAdapter {
  constructor(...args) {
    super(...args); // JM: It bugs me this is duplicated in the implementation but initialisation order makes it hard to avoid

    const [refListKey, refFieldPath] = this.config.ref.split('.');
    this.refListKey = refListKey;
    this.refFieldPath = refFieldPath;
    this.isRelationship = true;
  }

  addToMongooseSchema(schema, mongoose, rels) {
    // If we're relating to 'many' things, we don't store ids in this table
    if (!this.field.many) {
      // If we're the right hand side of a 1:1 relationship, do nothing.
      const {
        right,
        cardinality
      } = rels.find(({
        left,
        right
      }) => left.adapter === this || right && right.adapter === this);

      if (cardinality === '1:1' && right && right.adapter === this) {
        return;
      } // Otherwise, we're are hosting a foreign key


      const {
        refListKey: ref,
        config: {
          many
        }
      } = this;
      const type = many ? [ObjectId$1] : ObjectId$1; // FIXME: redundant?

      const schemaOptions = {
        type,
        ref
      };
      schema.add({
        [this.path]: this.mergeSchemaOptions(schemaOptions, this.config)
      });
    }
  }

  getRefListAdapter() {
    return this.getListByKey(this.refListKey).adapter;
  }

  getQueryConditions(dbPath) {
    return {
      [`${this.path}_is_null`]: value => ({
        [dbPath]: value ? {
          $not: {
            $exists: true,
            $ne: null
          }
        } : {
          $exists: true,
          $ne: null
        }
      })
    };
  }

  supportsRelationshipQuery(query) {
    return [this.path, `${this.path}_every`, `${this.path}_some`, `${this.path}_none`].includes(query);
  }

}

class KnexRelationshipInterface extends KnexFieldAdapter {
  constructor() {
    super(...arguments);
    this.isRelationship = true; // Default isIndexed to true if it's not explicitly provided
    // Mutually exclusive with isUnique

    this.isUnique = typeof this.config.isUnique === 'undefined' ? false : !!this.config.isUnique;
    this.isIndexed = typeof this.config.isIndexed === 'undefined' ? !this.config.isUnique : !!this.config.isIndexed; // JM: It bugs me this is duplicated in the implementation but initialisation order makes it hard to avoid

    const [refListKey, refFieldPath] = this.config.ref.split('.');
    this.refListKey = refListKey;
    this.refFieldPath = refFieldPath;
  } // Override the isNotNullable defaulting logic; default to false, not field.isRequired
  // Non-nullability of foreign keys in a one-to-many configuration causes problems with complicates creates
  // It implies a precedence in ordering of create operations and can break the nexted create resolvers
  // Also, if a pair of list both have a non-nullable relationship with the other, all inserts on either will fail


  get isNotNullable() {
    if (this._isNotNullable) return this._isNotNullable;
    return this._isNotNullable = !!(typeof this.knexOptions.isNotNullable === 'undefined' ? false : this.knexOptions.isNotNullable);
  }

  getRefListAdapter() {
    return this.getListByKey(this.refListKey).adapter;
  }

  addToTableSchema(table, rels) {
    // If we're relating to 'many' things, we don't store ids in this table
    if (!this.field.many) {
      // If we're the right hand side of a 1:1 relationship, do nothing.
      const {
        right,
        cardinality
      } = rels.find(({
        left,
        right
      }) => left.adapter === this || right && right.adapter === this);

      if (cardinality === '1:1' && right && right.adapter === this) {
        return;
      } // The foreign key needs to do this work for us; we don't know what type it is


      const refList = this.getListByKey(this.refListKey);
      const refId = refList.getPrimaryKey();
      const foreignKeyConfig = {
        path: this.path,
        isUnique: this.isUnique,
        isIndexed: this.isIndexed,
        isNotNullable: this.isNotNullable
      };
      refId.adapter.addToForeignTableSchema(table, foreignKeyConfig);
    }
  }

  getQueryConditions(dbPath) {
    return {
      [`${this.path}_is_null`]: value => b => value ? b.whereNull(dbPath) : b.whereNotNull(dbPath)
    };
  }

  supportsRelationshipQuery(query) {
    return [this.path, `${this.path}_every`, `${this.path}_some`, `${this.path}_none`].includes(query);
  }

}

var RelationshipType = {
  type: 'Relationship',
  isRelationship: true,
  // Used internally for this special case
  implementation: Relationship,
  views: {
    Controller: _join(__dirname, "1n73jn1"),
    Field: _join(__dirname, "15in0wx"),
    Filter: _join(__dirname, "t8xlg4"),
    Cell: _join(__dirname, "1ngepfp")
  },
  adapters: {
    mongoose: MongoRelationshipInterface,
    knex: KnexRelationshipInterface
  }
};

function ownKeys$7(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$7(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$7(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$7(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const RelationshipWrapper = _objectSpread$7(_objectSpread$7({}, RelationshipType), {}, {
  implementation: class extends RelationshipType.implementation {
    async resolveNestedOperations(operations, item, context, ...args) {
      const result = await super.resolveNestedOperations(operations, item, context, ...args);
      context._blockMeta = context._blockMeta || {};
      context._blockMeta[this.listKey] = context._blockMeta[this.listKey] || {};
      context._blockMeta[this.listKey][this.path] = result;
      return result;
    }

  }
});

class ImageBlock extends Block {
  constructor({
    adapter
  }, {
    fromList,
    joinList,
    createAuxList,
    getListByKey
  }) {
    super(...arguments);
    this.joinList = joinList;
    const auxListKey = `_Block_${fromList}_${this.type}`; // Ensure the list is only instantiated once per server instance.

    let auxList = getListByKey(auxListKey);

    if (!auxList) {
      auxList = createAuxList(auxListKey, {
        fields: {
          image: {
            type: CloudinaryImage$1,
            isRequired: true,
            adapter,
            schemaDoc: 'Cloudinary Image data returned from the Cloudinary API'
          },
          align: {
            type: SelectType,
            defaultValue: 'center',
            options: ['left', 'center', 'right'],
            schemaDoc: 'Set the image alignment'
          },
          // Useful for doing reverse lookups such as:
          // - "Get all images in this post"
          // - "List all users mentioned in comment"
          from: {
            type: RelationshipType,
            isRequired: true,
            ref: `${joinList}.${this.path}`,
            schemaDoc: 'A reference back to the Slate.js Serialised Document this image is embedded within'
          }
        }
      });
    }

    this.auxList = auxList;
  }

  get type() {
    return 'cloudinaryImage';
  }

  get path() {
    return pluralize.plural(this.type);
  }

  getAdminViews() {
    return [_join(__dirname, "clgmao"), ...new imageContainer().getAdminViews(), ...new caption().getAdminViews()];
  }

  getFieldDefinitions() {
    return {
      [this.path]: {
        type: RelationshipWrapper,
        ref: `${this.auxList.key}.from`,
        many: true,
        schemaDoc: 'Images which have been added to the Content field'
      }
    };
  }

  getMutationOperationResults({
    context
  }) {
    return {
      [this.path]: context._blockMeta && context._blockMeta[this.joinList] && context._blockMeta[this.joinList][this.path]
    };
  }

  getViewOptions() {
    return {
      query: `
        cloudinaryImages {
          id
          image {
            publicUrl
          }
          align
        }
      `
    };
  }

}

var CloudinaryImage$1 = {
  type: 'CloudinaryImage',
  implementation: CloudinaryImage,
  views: {
    Controller: _join(__dirname, "haf47u"),
    Field: _join(__dirname, "cnpn6s"),
    Cell: _join(__dirname, "1omu7q8")
  },
  adapters: {
    mongoose: MongoFileInterface,
    knex: KnexFileInterface
  },
  blocks: {
    image: ImageBlock // gallery: {
    //   type: 'cloudinaryGallery',
    // },

  }
};

function ownKeys$8(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$8(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$8(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$8(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

class Text extends Field {
  constructor(path, {
    isMultiline
  }) {
    super(...arguments);
    this.isMultiline = isMultiline;
    this.isOrderable = true;
  }

  gqlOutputFields() {
    return [`${this.path}: String`];
  }

  gqlOutputFieldResolvers() {
    return {
      [`${this.path}`]: item => item[this.path]
    };
  }

  gqlQueryInputFields() {
    return [...this.equalityInputFields('String'), ...this.stringInputFields('String'), ...this.equalityInputFieldsInsensitive('String'), ...this.stringInputFieldsInsensitive('String'), ...this.inInputFields('String')];
  }

  get gqlUpdateInputFields() {
    return [`${this.path}: String`];
  }

  get gqlCreateInputFields() {
    return [`${this.path}: String`];
  }

  extendAdminMeta(meta) {
    const {
      isMultiline
    } = this;
    return _objectSpread$8({
      isMultiline
    }, meta);
  }

}

const CommonTextInterface = superclass => class extends superclass {
  getQueryConditions(dbPath) {
    return _objectSpread$8(_objectSpread$8(_objectSpread$8(_objectSpread$8(_objectSpread$8({}, this.equalityConditions(dbPath)), this.stringConditions(dbPath)), this.equalityConditionsInsensitive(dbPath)), this.stringConditionsInsensitive(dbPath)), this.inConditions(dbPath));
  }

};

class MongoTextInterface extends CommonTextInterface(MongooseFieldAdapter) {
  addToMongooseSchema(schema) {
    schema.add({
      [this.path]: this.mergeSchemaOptions({
        type: String
      }, this.config)
    });
  }

}

class KnexTextInterface extends CommonTextInterface(KnexFieldAdapter) {
  constructor() {
    super(...arguments);
    this.isUnique = !!this.config.isUnique;
    this.isIndexed = !!this.config.isIndexed && !this.config.isUnique;
  }

  addToTableSchema(table) {
    const column = table.text(this.path);
    if (this.isUnique) column.unique();else if (this.isIndexed) column.index();
    if (this.isNotNullable) column.notNullable();
    if (typeof this.defaultTo !== 'undefined') column.defaultTo(this.defaultTo);
  }

}

var index$2 = {
  type: 'Color',
  implementation: Text,
  views: {
    Controller: _join(__dirname, "wneme6"),
    Field: _join(__dirname, "rb66go"),
    Cell: _join(__dirname, "1fzegpt"),
    Filter: _join(__dirname, "1603tj9")
  },
  adapters: {
    mongoose: MongoTextInterface,
    knex: KnexTextInterface
  }
};

function ownKeys$9(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$9(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$9(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$9(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

class _DateTime extends Field {
  constructor(path, {
    format,
    yearRangeFrom,
    yearRangeTo,
    yearPickerType
  }) {
    super(...arguments);
    this.format = format;
    this.yearRangeFrom = yearRangeFrom;
    this.yearRangeTo = yearRangeTo;
    this.yearPickerType = yearPickerType;
    this.isOrderable = true;
  }

  gqlOutputFields() {
    return [`${this.path}: DateTime`];
  }

  gqlQueryInputFields() {
    return [...this.equalityInputFields('DateTime'), ...this.orderingInputFields('DateTime'), ...this.inInputFields('DateTime')];
  }

  get gqlUpdateInputFields() {
    return [`${this.path}: DateTime`];
  }

  get gqlCreateInputFields() {
    return [`${this.path}: DateTime`];
  }

  getGqlAuxTypes() {
    return [`scalar DateTime`];
  }

  extendAdminMeta(meta) {
    return _objectSpread$9(_objectSpread$9({}, meta), {}, {
      format: this.format,
      yearRangeFrom: this.yearRangeFrom,
      yearRangeTo: this.yearRangeTo,
      yearPickerType: this.yearPickerType
    });
  }

  gqlAuxFieldResolvers() {
    return {
      DateTime: new GraphQLScalarType({
        name: 'DateTime',
        description: 'DateTime custom scalar represents an ISO 8601 datetime string',

        parseValue(value) {
          return value; // value from the client
        },

        serialize(value) {
          return value; // value sent to the client
        },

        parseLiteral(ast) {
          if (ast.kind === Kind.STRING) {
            return ast.value; // ast value is always in string format
          }

          return null;
        }

      })
    };
  }

}

const toDate = s => s && DateTime.fromISO(s, {
  zone: 'utc'
}).toJSDate();

const CommonDateTimeInterface = superclass => class extends superclass {
  setupHooks({
    addPreSaveHook,
    addPostReadHook
  }) {
    const field_path = this.path;
    const utc_field = `${field_path}_utc`;
    const offset_field = `${field_path}_offset`; // Updates the relevant value in the item provided (by referrence)

    addPreSaveHook(item => {
      // Only run the hook if the item actually contains the datetime field
      // NOTE: Can't use hasOwnProperty here, as the mongoose data object
      // returned isn't a POJO
      if (!(field_path in item)) {
        return item;
      }

      const datetimeString = item[field_path]; // NOTE: Even though `0` is a valid timestamp (the unix epoch), it's not a valid ISO string,
      // so it's ok to check for falseyness here.

      if (!datetimeString) {
        item[utc_field] = null;
        item[offset_field] = null;
        delete item[field_path]; // Never store this field

        return item;
      }

      if (!DateTime.fromISO(datetimeString, {
        zone: 'utc'
      }).isValid) {
        throw new Error('Validation failed: DateTime must be either `null` or a valid ISO 8601 string');
      }

      item[utc_field] = toDate(datetimeString);
      item[offset_field] = DateTime.fromISO(datetimeString, {
        setZone: true
      }).toFormat('ZZ');
      delete item[field_path]; // Never store this field

      return item;
    });
    addPostReadHook(item => {
      // If there's no fields stored in the DB (can happen with MongoDB), then
      // don't bother trying to process anything
      // NOTE: Can't use hasOwnProperty here, as the mongoose data object
      // returned isn't a POJO
      if (!(utc_field in item) && !(offset_field in item)) {
        return item;
      }

      if (!item[utc_field] || !item[offset_field]) {
        item[field_path] = null;
        return item;
      }

      const datetimeString = DateTime.fromJSDate(item[utc_field], {
        zone: 'utc'
      }).setZone(new FixedOffsetZone(DateTime.fromISO(`1234-01-01T00:00:00${item[offset_field]}`, {
        setZone: true
      }).offset)).toISO();
      item[field_path] = datetimeString;
      item[utc_field] = undefined;
      item[offset_field] = undefined;
      return item;
    });
  }

  getQueryConditions(dbPath) {
    return _objectSpread$9(_objectSpread$9(_objectSpread$9({}, this.equalityConditions(dbPath, toDate)), this.orderingConditions(dbPath, toDate)), this.inConditions(dbPath, toDate));
  }

};

class MongoDateTimeInterface extends CommonDateTimeInterface(MongooseFieldAdapter) {
  constructor() {
    super(...arguments);
    this.utcPath = `${this.path}_utc`;
    this.offsetPath = `${this.path}_offset`;
    this.realKeys = [this.utcPath, this.offsetPath];
    this.dbPath = this.utcPath;
  }

  addToMongooseSchema(schema) {
    const {
      mongooseOptions
    } = this.config;
    schema.add({
      // FIXME: Mongoose needs to know about this field in order for the correct
      // attributes to make it through to the pre-hooks.
      [this.path]: _objectSpread$9({
        type: String
      }, mongooseOptions),
      // These are the actual fields we care about storing in the database.
      [this.utcPath]: _objectSpread$9({
        type: Date
      }, mongooseOptions),
      [this.offsetPath]: _objectSpread$9({
        type: String
      }, mongooseOptions)
    });
  }

  getMongoFieldName() {
    return `${this.path}_utc`;
  }

}

class KnexDateTimeInterface extends CommonDateTimeInterface(KnexFieldAdapter) {
  constructor() {
    super(...arguments);
    this.utcPath = `${this.path}_utc`;
    this.offsetPath = `${this.path}_offset`;
    this.realKeys = [this.utcPath, this.offsetPath];
    this.sortKey = this.utcPath;
    this.dbPath = this.utcPath;
    this.isUnique = !!this.config.isUnique;
    this.isIndexed = !!this.config.isIndexed && !this.config.isUnique;
  }

  addToTableSchema(table) {
    // TODO: Should use a single field on PG
    // .. although 2 cols is nice for MySQL (no native datetime with tz)
    const utcColumn = table.timestamp(this.utcPath, {
      useTz: false
    });
    const offsetColumn = table.text(this.offsetPath); // Interpret the index options as effecting both elements

    if (this.isUnique) table.unique([this.utcPath, this.offsetPath]);else if (this.isIndexed) table.index([this.utcPath, this.offsetPath]); // Interpret not nullable to mean neither field is nullable

    if (this.isNotNullable) {
      utcColumn.notNullable();
      offsetColumn.notNullable();
    } // Allow defaults to be set for both elements of the value by nesting them
    // TODO: Add to docs..


    if (this.defaultTo && (this.defaultTo.utc || this.defaultTo.offset)) {
      if (this.defaultTo.utc) utcColumn.defaultTo(this.defaultTo.utc);
      if (this.defaultTo.offset) offsetColumn.defaultTo(this.defaultTo.offset);
    } else if (this.defaultTo) {
      utcColumn.defaultTo(this.defaultTo);
    }
  }

}

var index$3 = {
  type: 'DateTime',
  implementation: _DateTime,
  views: {
    Controller: _join(__dirname, "hlr4ay"),
    Field: _join(__dirname, "1r0c33v"),
    Filter: _join(__dirname, "15zs31"),
    Cell: _join(__dirname, "crtxqs")
  },
  adapters: {
    mongoose: MongoDateTimeInterface,
    knex: KnexDateTimeInterface
  }
};

function ownKeys$a(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$a(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$a(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$a(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

class Decimal extends Field {
  constructor(path, {
    symbol
  }) {
    super(...arguments);
    this.symbol = symbol;
    this.isOrderable = true;
  }

  gqlOutputFields() {
    return [`${this.path}: String`];
  }

  gqlOutputFieldResolvers() {
    return {
      [`${this.path}`]: item => item[this.path]
    };
  }

  gqlQueryInputFields() {
    return [...this.equalityInputFields('String'), ...this.orderingInputFields('String'), ...this.inInputFields('String')];
  }

  get gqlUpdateInputFields() {
    return [`${this.path}: String`];
  }

  get gqlCreateInputFields() {
    return [`${this.path}: String`];
  }

  extendAdminMeta(meta) {
    return _objectSpread$a(_objectSpread$a({}, meta), {}, {
      symbol: this.symbol
    });
  }

}

class MongoDecimalInterface extends MongooseFieldAdapter {
  addToMongooseSchema(schema) {
    const validator = a => typeof a === 'object' && /^-?\d*\.?\d*$/.test(a);

    const schemaOptions = {
      type: mongoose.Decimal128,
      validate: {
        validator: this.buildValidator(validator),
        message: '{VALUE} is not a Decimal value'
      }
    };
    schema.add({
      [this.path]: this.mergeSchemaOptions(schemaOptions, this.config)
    });
  }

  setupHooks({
    addPreSaveHook,
    addPostReadHook
  }) {
    // Updates the relevant value in the item provided (by reference)
    addPreSaveHook(item => {
      // Only run the hook if the item actually contains the field
      // NOTE: Can't use hasOwnProperty here, as the mongoose data object
      // returned isn't a POJO
      if (!(this.path in item)) {
        return item;
      }

      if (item[this.path]) {
        if (typeof item[this.path] === 'string') {
          item[this.path] = mongoose.Types.Decimal128.fromString(item[this.path]);
        } else {
          // Should have been caught by the validator??
          throw `Invalid Decimal value given for '${this.path}'`;
        }
      } else {
        item[this.path] = null;
      } // else: Must either be undefined or a Decimal128 object, so leave it alone.


      return item;
    });
    addPostReadHook(item => {
      if (item[this.path]) {
        item[this.path] = item[this.path].toString();
      }

      return item;
    });
  }

  getQueryConditions(dbPath) {
    return _objectSpread$a(_objectSpread$a(_objectSpread$a({}, this.equalityConditions(dbPath, mongoose.Types.Decimal128.fromString)), this.orderingConditions(dbPath, mongoose.Types.Decimal128.fromString)), this.inConditions(dbPath, mongoose.Types.Decimal128.fromString));
  }

}

class KnexDecimalInterface extends KnexFieldAdapter {
  constructor() {
    super(...arguments);
    this.isUnique = !!this.config.isUnique;
    this.isIndexed = !!this.config.isIndexed && !this.config.isUnique; // In addition to the standard knexOptions this type supports precision and scale

    const {
      precision,
      scale
    } = this.knexOptions;
    this.precision = precision === null ? null : parseInt(precision) || 18;
    this.scale = scale === null ? null : (this.precision, parseInt(scale) || 4);

    if (this.scale !== null && this.precision !== null && this.scale > this.precision) {
      throw `The scale configured for Decimal field '${this.path}' (${this.scale}) ` + `must not be larger than the field's precision (${this.precision})`;
    }
  }

  addToTableSchema(table) {
    const column = table.decimal(this.path, this.precision, this.scale);
    if (this.isUnique) column.unique();else if (this.isIndexed) column.index();
    if (this.isNotNullable) column.notNullable();
    if (typeof this.defaultTo !== 'undefined') column.defaultTo(this.defaultTo);
  }

  getQueryConditions(dbPath) {
    return _objectSpread$a(_objectSpread$a(_objectSpread$a({}, this.equalityConditions(dbPath)), this.orderingConditions(dbPath)), this.inConditions(dbPath));
  }

}

var index$4 = {
  type: 'Decimal',
  implementation: Decimal,
  views: {
    Controller: _join(__dirname, "118m09z"),
    Field: _join(__dirname, "sg6d6v"),
    Filter: _join(__dirname, "14ybajw")
  },
  adapters: {
    mongoose: MongoDecimalInterface,
    knex: KnexDecimalInterface
  }
};
var index$5 = {
  type: 'File',
  implementation: File,
  views: {
    Controller: _join(__dirname, "tbs8uc"),
    Field: _join(__dirname, "kpf3q7"),
    Cell: _join(__dirname, "53k0ro")
  },
  adapters: {
    mongoose: MongoFileInterface,
    knex: KnexFileInterface
  }
};

function ownKeys$b(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$b(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$b(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$b(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

class Float extends Field {
  constructor() {
    super(...arguments);
    this.isOrderable = true;
  }

  gqlOutputFields() {
    return [`${this.path}: Float`];
  }

  gqlOutputFieldResolvers() {
    return {
      [`${this.path}`]: item => item[this.path]
    };
  }

  gqlQueryInputFields() {
    return [...this.equalityInputFields('Float'), ...this.orderingInputFields('Float'), ...this.inInputFields('Float')];
  }

  get gqlUpdateInputFields() {
    return [`${this.path}: Float`];
  }

  get gqlCreateInputFields() {
    return [`${this.path}: Float`];
  }

}

const CommonFloatInterface = superclass => class extends superclass {
  getQueryConditions(dbPath) {
    return _objectSpread$b(_objectSpread$b(_objectSpread$b({}, this.equalityConditions(dbPath)), this.orderingConditions(dbPath)), this.inConditions(dbPath));
  }

};

class MongoFloatInterface extends CommonFloatInterface(MongooseFieldAdapter) {
  addToMongooseSchema(schema) {
    schema.add({
      [this.path]: this.mergeSchemaOptions({
        type: Number
      }, this.config)
    });
  }

}

class KnexFloatInterface extends CommonFloatInterface(KnexFieldAdapter) {
  constructor() {
    super(...arguments);
    this.isUnique = !!this.config.isUnique;
    this.isIndexed = !!this.config.isIndexed && !this.config.isUnique;
  }

  addToTableSchema(table) {
    const column = table.float(this.path);
    if (this.isUnique) column.unique();else if (this.isIndexed) column.index();
    if (this.isNotNullable) column.notNullable();
    if (typeof this.defaultTo !== 'undefined') column.defaultTo(this.defaultTo);
  }

}

var index$6 = {
  type: 'Float',
  implementation: Float,
  views: {
    Controller: _join(__dirname, "ahdnug"),
    Field: _join(__dirname, "1af09zh"),
    Filter: _join(__dirname, "7hd0gj")
  },
  adapters: {
    mongoose: MongoFloatInterface,
    knex: KnexFloatInterface
  }
};

function ownKeys$c(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$c(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$c(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$c(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

class Integer extends Field {
  constructor() {
    super(...arguments);
    this.isOrderable = true;
  }

  gqlOutputFields() {
    return [`${this.path}: Int`];
  }

  gqlOutputFieldResolvers() {
    return {
      [`${this.path}`]: item => item[this.path]
    };
  }

  gqlQueryInputFields() {
    return [...this.equalityInputFields('Int'), ...this.orderingInputFields('Int'), ...this.inInputFields('Int')];
  }

  get gqlUpdateInputFields() {
    return [`${this.path}: Int`];
  }

  get gqlCreateInputFields() {
    return [`${this.path}: Int`];
  }

}

const CommonIntegerInterface = superclass => class extends superclass {
  getQueryConditions(dbPath) {
    return _objectSpread$c(_objectSpread$c(_objectSpread$c({}, this.equalityConditions(dbPath)), this.orderingConditions(dbPath)), this.inConditions(dbPath));
  }

};

class MongoIntegerInterface extends CommonIntegerInterface(MongooseFieldAdapter) {
  addToMongooseSchema(schema) {
    const schemaOptions = {
      type: Number,
      validate: {
        validator: this.buildValidator(a => typeof a === 'number' && Number.isInteger(a)),
        message: '{VALUE} is not an integer value'
      }
    };
    schema.add({
      [this.path]: this.mergeSchemaOptions(schemaOptions, this.config)
    });
  }

}

class KnexIntegerInterface extends CommonIntegerInterface(KnexFieldAdapter) {
  constructor() {
    super(...arguments);
    this.isUnique = !!this.config.isUnique;
    this.isIndexed = !!this.config.isIndexed && !this.config.isUnique;
  }

  addToTableSchema(table) {
    const column = table.integer(this.path);
    if (this.isUnique) column.unique();else if (this.isIndexed) column.index();
    if (this.isNotNullable) column.notNullable();
    if (typeof this.defaultTo !== 'undefined') column.defaultTo(this.defaultTo);
  }

}

var index$7 = {
  type: 'Integer',
  implementation: Integer,
  views: {
    Controller: _join(__dirname, "ua0r21"),
    Field: _join(__dirname, "ogdh30"),
    Filter: _join(__dirname, "1izcksw")
  },
  adapters: {
    mongoose: MongoIntegerInterface,
    knex: KnexIntegerInterface
  }
};

function ownKeys$d(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$d(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$d(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$d(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
} // https://github.com/Automattic/mongoose/blob/master/migrating_to_5.md#checking-if-a-path-is-populated


mongoose.set('objectIdGetter', false);
const {
  Types: {
    ObjectId: ObjectId$2
  }
} = mongoose;

class Location extends Field {
  constructor(_, {
    googleMapsKey
  }) {
    super(...arguments);
    this.graphQLOutputType = 'Location';

    if (!googleMapsKey) {
      throw new Error('You must provide a `googleMapsKey` to Location Field. To generate a Google Maps API please visit: https://developers.google.com/maps/documentation/javascript/get-api-key');
    }

    this._googleMapsKey = googleMapsKey;
  }

  extendAdminMeta(meta) {
    return _objectSpread$d(_objectSpread$d({}, meta), {}, {
      googleMapsKey: this._googleMapsKey
    });
  }

  gqlOutputFields() {
    return [`${this.path}: ${this.graphQLOutputType}`];
  }

  gqlQueryInputFields() {
    return [...this.equalityInputFields('String'), ...this.stringInputFields('String'), ...this.inInputFields('String')];
  }

  getGqlAuxTypes() {
    return [`
      type ${this.graphQLOutputType} {
        id: ID
        googlePlaceID: String
        formattedAddress: String
        lat: Float
        lng: Float
      }
    `];
  } // Called on `User.avatar` for example


  gqlOutputFieldResolvers() {
    return {
      [this.path]: item => {
        const itemValues = item[this.path];

        if (!itemValues) {
          return null;
        }

        return itemValues;
      }
    };
  }

  async resolveInput({
    resolvedData
  }) {
    const placeId = resolvedData[this.path]; // NOTE: The following two conditions could easily be combined into a
    // single `if (!inputId) return inputId`, but that would lose the nuance of
    // returning `undefined` vs `null`.
    // Premature Optimisers; be ware!

    if (typeof placeId === 'undefined') {
      // Nothing was passed in, so we can bail early.
      return undefined;
    }

    if (placeId === null) {
      // `null` was specifically set, and we should set the field value to null
      // To do that we... return `null`
      return null;
    }

    const response = await fetch(`https://maps.googleapis.com/maps/api/geocode/json?place_id=${placeId}&key=${this._googleMapsKey}`).then(r => r.json());

    if (response.results && response.results[0]) {
      const {
        place_id,
        formatted_address
      } = response.results[0];
      const {
        lat,
        lng
      } = response.results[0].geometry.location;
      return {
        id: new ObjectId$2(),
        googlePlaceID: place_id,
        formattedAddress: formatted_address,
        lat: lat,
        lng: lng
      };
    }

    return null;
  }

  get gqlUpdateInputFields() {
    return [`${this.path}: String`];
  }

  get gqlCreateInputFields() {
    return [`${this.path}: String`];
  }

}

const CommonLocationInterface = superclass => class extends superclass {
  getQueryConditions(dbPath) {
    return _objectSpread$d(_objectSpread$d(_objectSpread$d({}, this.equalityConditions(dbPath)), this.stringConditions(dbPath)), this.inConditions(dbPath));
  }

};

class MongoLocationInterface extends CommonLocationInterface(MongooseFieldAdapter) {
  addToMongooseSchema(schema) {
    const schemaOptions = {
      type: {
        id: ObjectId$2,
        googlePlaceID: String,
        formattedAddress: String,
        lat: Number,
        lng: Number
      }
    };
    schema.add({
      [this.path]: this.mergeSchemaOptions(schemaOptions, this.config)
    });
  }

}

class KnexLocationInterface extends CommonLocationInterface(KnexFieldAdapter) {
  constructor() {
    super(...arguments); // Error rather than ignoring invalid config
    // We totally can index these values, it's just not trivial. See issue #1297

    if (this.config.isUnique || this.config.isIndexed) {
      throw `The Location field type doesn't support indexes on Knex. ` + `Check the config for ${this.path} on the ${this.field.listKey} list`;
    }
  }

  addToTableSchema(table) {
    const column = table.jsonb(this.path);
    if (this.isNotNullable) column.notNullable();
    if (this.defaultTo) column.defaultTo(this.defaultTo);
  }

}

var index$8 = {
  type: 'Location',
  implementation: Location,
  views: {
    Controller: _join(__dirname, "4u4ry3"),
    Field: _join(__dirname, "cnp9lf"),
    Cell: _join(__dirname, "1u3lhxi"),
    Filter: _join(__dirname, "1603tj9")
  },
  adapters: {
    mongoose: MongoLocationInterface,
    knex: KnexLocationInterface
  }
};

function ownKeys$e(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$e(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$e(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$e(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

class OEmbed extends Field {
  constructor(path, {
    adapter,
    parameters = {}
  }, {
    listKey
  }) {
    super(...arguments);

    if (!adapter) {
      throw new Error(`An OEmbed Adapter must be supplied for the OEmbed field to fetch oEmbed data. See the ${listKey}.${path} field.`);
    }

    if (typeof adapter.fetch !== 'function') {
      throw new Error(`An invalid OEmbed Adapter was set on the ${listKey}.${path} field - it does not implement the #fetch() method.`);
    }

    if (typeof parameters !== 'object') {
      throw new Error(`parameters passed to the OEmbed Adapter must be an object. See the ${listKey}.${path} field.`);
    }

    this.graphQLOutputType = 'OEmbed';
    this.adapter = adapter;
    this.parameters = parameters;
  }

  gqlOutputFields() {
    return [`${this.path}: ${this.graphQLOutputType}`];
  }

  gqlQueryInputFields() {
    return [...this.equalityInputFields('String'), ...this.stringInputFields('String'), ...this.inInputFields('String')];
  }

  getGqlAuxTypes() {
    const baseFields = `
      # The resource type. One of 'photo'/'video'/'link'/'rich'
      type: String!
      # The original input URL which the oEmbed data was generated from
      originalUrl: String!
      # The oEmbed version number. Will be 1.0.
      version: String
      # A text title, describing the resource.
      title: String
      # The suggested cache lifetime for this resource, in seconds. Consumers may choose to use this value or not.
      cacheAge: String
      # The resource provider.
      provider: ${this.graphQLOutputType}Provider
      # The author/owner of the resource.
      author: ${this.graphQLOutputType}Author
      # An optional thumbnail image representing the resource.
      thumbnail: ${this.graphQLOutputType}Thumbnail
    `;
    return [`
        type ${this.graphQLOutputType}Thumbnail {
          # A URL to a thumbnail image
          url: String!
          # The width of the thumbnail in pixels
          width: String!
          # The height of the thumbnail
          height: String!
        }
      `, `
        type ${this.graphQLOutputType}Author {
          # The name of the author/owner of the resource.
          name: String
          # A URL for the author/owner of the resource.
          url: String
        }
      `, `
        type ${this.graphQLOutputType}Provider {
          # The name of the resource provider.
          name: String
          # The url of the resource provider.
          url: String
        }
      `, `
        """
        The base ${this.graphQLOutputType} type.
        See the following implementations:
        - ${this.graphQLOutputType}Link
        - ${this.graphQLOutputType}Photo
        - ${this.graphQLOutputType}Video
        - ${this.graphQLOutputType}Rich
        """
        interface ${this.graphQLOutputType} {
          ${baseFields}
        }
      `, // NOTE: The Link type only implements the base fields
    `
        # Generic embed data.
        type ${this.graphQLOutputType}Link implements ${this.graphQLOutputType} {
          ${baseFields}
        }
      `, `
        # This type is used for representing static photos in oEmbed data.
        type ${this.graphQLOutputType}Photo implements ${this.graphQLOutputType} {
          ${baseFields}
          # The source URL of the image. Consumers should be able to insert this URL into an <img> element. Only HTTP and HTTPS URLs are valid.
          url: String!
          # The width in pixels of the image
          width: String
          # The height in pixels of the image
          height: String
        }
      `, `
        # This type is used for representing playable videos in oEmbed data.
        type ${this.graphQLOutputType}Video implements ${this.graphQLOutputType} {
          ${baseFields}
          # The HTML required to embed a video player. The HTML should have no padding or margins. Consumers may wish to load the HTML in an off-domain iframe to avoid XSS vulnerabilities.
          html: String!
          # The width in pixels required to display the HTML.
          width: String
          # The height in pixels required to display the HTML.
          height: String
        }
      `, `
        # This type is used for rich HTML content that does not fall under ${this.graphQLOutputType}Link, ${this.graphQLOutputType}Photo, or ${this.graphQLOutputType}Video.
        type ${this.graphQLOutputType}Rich implements ${this.graphQLOutputType} {
          ${baseFields}
          # The HTML required to display the resource. The HTML should have no padding or margins. Consumers may wish to load the HTML in an off-domain iframe to avoid XSS vulnerabilities. The markup should be valid XHTML 1.0 Basic.
          html: String!
          # The width in pixels required to display the HTML.
          width: String
          # The height in pixels required to display the HTML.
          height: String
        }
      `];
  } // Called on `User.avatar` for example


  gqlOutputFieldResolvers() {
    return {
      [this.path]: item => {
        if (!item[this.path]) {
          return null;
        } // Because we're returning an interface, we have to tell GraphQL what
        // __typename to use.


        let __typename = {
          photo: `${this.graphQLOutputType}Photo`,
          video: `${this.graphQLOutputType}Video`,
          link: `${this.graphQLOutputType}Link`,
          rich: `${this.graphQLOutputType}Rich`
        }[item[this.path].type];
        return _objectSpread$e(_objectSpread$e({}, item[this.path]), {}, {
          __typename
        });
      }
    };
  }

  async resolveInput({
    resolvedData
  }) {
    const inputUrl = resolvedData[this.path]; // NOTE: The following two conditions could easily be combined into a
    // single `if (!inputUrl) return inputUrl`, but that would lose the nuance of
    // returning `undefined` vs `null`.
    // Premature Optimisers; be ware!

    if (typeof inputUrl === 'undefined') {
      // Nothing was passed in, so we can bail early.
      return undefined;
    }

    if (inputUrl === null || inputUrl.trim() === '') {
      // `null` or `''` was specifically uploaded, and we should set the field
      // value to null. To do that we... return `null`
      return null;
    } // Pull all possible oEmbed fields from the adapter


    const {
      type,
      version,
      title,
      author_name,
      author_url,
      provider_name,
      provider_url,
      cache_age,
      thumbnail_url,
      thumbnail_width,
      thumbnail_height,
      url,
      html,
      width,
      height,
      error
    } = await this.adapter.fetch(_objectSpread$e(_objectSpread$e({}, this.parameters), {}, {
      // Force the url parameter
      url: inputUrl
    })); // Convert them into a more GraphQL friendly format

    return {
      originalUrl: inputUrl,
      type: type || 'link',
      version,
      title,
      cache_age,
      // Only parts of the author might exist
      author: author_name || author_url ? {
        name: author_name || null,
        url: author_url || null
      } : null,
      // Only parts of the author might exist
      provider: provider_name || provider_url ? {
        name: provider_name || null,
        url: provider_url || null
      } : null,
      // All fields of thumbnail are required
      thumbnail: thumbnail_url && thumbnail_width && thumbnail_height ? {
        url: thumbnail_url,
        width: thumbnail_width,
        height: thumbnail_height
      } : null,
      url,
      html,
      width,
      height,
      error
    };
  }

  get gqlUpdateInputFields() {
    return [`${this.path}: String`];
  }

  get gqlCreateInputFields() {
    return [`${this.path}: String`];
  }

}

const CommonOEmbedInterface = superclass => class extends superclass {
  getQueryConditions(dbPath) {
    return _objectSpread$e(_objectSpread$e(_objectSpread$e({}, this.equalityConditions(dbPath)), this.stringConditions(dbPath)), this.inConditions(dbPath));
  }

};

class MongoOEmbedInterface extends CommonOEmbedInterface(MongooseFieldAdapter) {
  addToMongooseSchema(schema) {
    const schemaOptions = {
      type: Object
    };
    schema.add({
      [this.path]: this.mergeSchemaOptions(schemaOptions, this.config)
    });
  }

}

class KnexOEmbedInterface extends CommonOEmbedInterface(KnexFieldAdapter) {
  constructor() {
    super(...arguments); // Error rather than ignoring invalid config
    // We totally can index these values, it's just not trivial. See issue #1297

    if (this.config.isUnique || this.config.isIndexed) {
      throw `The OEmbed field type doesn't support indexes on Knex. ` + `Check the config for ${this.path} on the ${this.field.listKey} list`;
    }
  }

  addToTableSchema(table) {
    const column = table.jsonb(this.path);
    if (this.isNotNullable) column.notNullable();
    if (this.defaultTo) column.defaultTo(this.defaultTo);
  }

}

function ownKeys$f(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$f(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$f(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$f(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const RelationshipWrapper$1 = _objectSpread$f(_objectSpread$f({}, RelationshipType), {}, {
  implementation: class extends RelationshipType.implementation {
    async resolveNestedOperations(operations, item, context, ...args) {
      const result = await super.resolveNestedOperations(operations, item, context, ...args);
      context._blockMeta = context._blockMeta || {};
      context._blockMeta[this.listKey] = context._blockMeta[this.listKey] || {};
      context._blockMeta[this.listKey][this.path] = result;
      return result;
    }

  }
});

class OEmbedBlock extends Block {
  constructor({
    adapter
  }, {
    fromList,
    joinList,
    createAuxList,
    getListByKey
  }) {
    super(...arguments);
    this.joinList = joinList;
    this.adapter = adapter;
    const auxListKey = `_Block_${fromList}_${this.type}`; // Ensure the list is only instantiated once per server instance.

    let auxList = getListByKey(auxListKey);

    if (!auxList) {
      auxList = createAuxList(auxListKey, {
        fields: {
          embed: {
            type: OEmbed$1,
            isRequired: true,
            adapter,
            schemaDoc: 'oEmbed data as returned by the passed adapter'
          },
          // Useful for doing reverse lookups such as:
          // - "Get all embeds in this post"
          // - "List all users mentioned in comment"
          from: {
            type: RelationshipType,
            isRequired: true,
            ref: `${joinList}.${this.path}`,
            schemaDoc: 'A reference back to the Slate.js Serialised Document this embed is contained within'
          }
        }
      });
    }

    this.auxList = auxList;
  }

  get type() {
    return 'oEmbed';
  }

  get path() {
    return pluralize.plural(this.type);
  }

  getFieldDefinitions() {
    return {
      [this.path]: {
        type: RelationshipWrapper$1,
        ref: `${this.auxList.key}.from`,
        many: true,
        schemaDoc: 'Embeds which have been added to the Content field'
      }
    };
  }

  getMutationOperationResults({
    context
  }) {
    return {
      [this.path]: context._blockMeta && context._blockMeta[this.joinList] && context._blockMeta[this.joinList][this.path]
    };
  }

  getAdminViews() {
    return [_join(__dirname, "ayx28x"), ...(typeof this.adapter.getAdminViews === 'function' ? this.adapter.getAdminViews() : [])];
  }

  getViewOptions() {
    return _objectSpread$f({
      query: `
        oEmbeds {
          id
          embed {
            type
            originalUrl
            version
            title
            cacheAge
            provider {
              name
              url
            }
            author {
              name
              url
            }
            thumbnail {
              url
              width
              height
            }
            ...on OEmbedPhoto {
              url
              width
              height
            }
            ...on OEmbedVideo {
              html
              width
              height
            }
            ...on OEmbedRich {
              html
              width
              height
            }
          }
        }
      `
    }, typeof this.adapter.getViewOptions === 'function' ? this.adapter.getViewOptions() : {});
  }

}

var OEmbed$1 = {
  type: 'OEmbed',
  implementation: OEmbed,
  views: {
    Controller: _join(__dirname, "wgjdbb"),
    Field: _join(__dirname, "1dqigo0"),
    Cell: _join(__dirname, "wa23jc")
  },
  adapters: {
    mongoose: MongoOEmbedInterface,
    knex: KnexOEmbedInterface
  },
  blocks: {
    oEmbed: OEmbedBlock
  }
};

function ownKeys$g(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$g(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$g(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$g(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const bcryptHashRegex = /^\$2[aby]?\$\d{1,2}\$[.\/A-Za-z0-9]{53}$/;

class Password extends Field {
  constructor(path, {
    rejectCommon,
    minLength,
    workFactor,
    useCompiledBcrypt
  }) {
    super(...arguments);
    this.bcrypt = require(useCompiledBcrypt ? 'bcrypt' : 'bcryptjs'); // Sanitise field specific config

    this.rejectCommon = !!rejectCommon;
    this.minLength = Math.max(Number.parseInt(minLength) || 8, 1); // Min 4, max: 31, default: 10

    this.workFactor = Math.min(Math.max(Number.parseInt(workFactor) || 10, 4), 31);

    if (this.workFactor < 6) {
      console.warn(`The workFactor for ${this.listKey}.${this.path} is very low! ` + `This will cause weak hashes!`);
    }
  }

  gqlOutputFields() {
    return [`${this.path}_is_set: Boolean`];
  }

  gqlOutputFieldResolvers() {
    return {
      [`${this.path}_is_set`]: item => {
        const val = item[this.path];
        return bcryptHashRegex.test(val);
      }
    };
  }

  gqlQueryInputFields() {
    return [`${this.path}_is_set: Boolean`];
  }

  get gqlUpdateInputFields() {
    return [`${this.path}: String`];
  }

  get gqlCreateInputFields() {
    return [`${this.path}: String`];
  } // Wrap bcrypt functionality
  // The compare() and compareSync() functions are constant-time
  // The compare() and generateHash() functions will return a Promise if no call back is provided


  compare(candidate, hash, callback) {
    return this.bcrypt.compare(candidate, hash, callback);
  }

  compareSync(candidate, hash) {
    return this.bcrypt.compareSync(candidate, hash);
  }

  generateHash(plaintext, callback) {
    this.validateNewPassword(plaintext);
    return this.bcrypt.hash(plaintext, this.workFactor, callback);
  }

  generateHashSync(plaintext) {
    this.validateNewPassword(plaintext);
    return this.bcrypt.hashSync(plaintext, this.workFactor);
  }

  extendAdminMeta(meta) {
    const {
      minLength
    } = this;
    return _objectSpread$g(_objectSpread$g({}, meta), {}, {
      minLength
    });
  } // Force values to be hashed when set


  validateNewPassword(password) {
    if (this.rejectCommon && dumbPasswords.check(password)) {
      throw new Error(`[password:rejectCommon:${this.listKey}:${this.path}] Common and frequently-used passwords are not allowed.`);
    } // TODO: checking string length is not simple; might need to revisit this (see https://mathiasbynens.be/notes/javascript-unicode)


    if (String(password).length < this.minLength) {
      throw new Error(`[password:minLength:${this.listKey}:${this.path}] Value must be at least ${this.minLength} characters long.`);
    }
  }

}

const CommonPasswordInterface = superclass => class extends superclass {
  setupHooks({
    addPreSaveHook
  }) {
    // Updates the relevant value in the item provided (by referrence)
    addPreSaveHook(async item => {
      const path = this.field.path;
      const plaintext = item[path]; // Only run the hook if the item actually contains the field
      // NOTE: Can't use hasOwnProperty here, as the mongoose data object
      // returned isn't a POJO

      if (!(path in item)) {
        return item;
      }

      if (plaintext) {
        if (typeof plaintext === 'string') {
          item[path] = await this.field.generateHash(plaintext);
        } else {
          // Should have been caught by the validator??
          throw `Invalid Password value given for '${path}'`;
        }
      } else {
        item[path] = null;
      }

      return item;
    });
  }

};

class MongoPasswordInterface extends CommonPasswordInterface(MongooseFieldAdapter) {
  addToMongooseSchema(schema) {
    schema.add({
      [this.path]: this.mergeSchemaOptions({
        type: String
      }, this.config)
    });
  }

  getQueryConditions(dbPath) {
    return {
      [`${this.path}_is_set`]: value => ({
        [dbPath]: value ? {
          $regex: bcryptHashRegex
        } : {
          $not: bcryptHashRegex
        }
      })
    };
  }

}

class KnexPasswordInterface extends CommonPasswordInterface(KnexFieldAdapter) {
  constructor() {
    super(...arguments); // Error rather than ignoring invalid config

    if (this.config.isUnique || this.config.isIndexed) {
      throw `The Password field type doesn't support indexes on Knex. ` + `Check the config for ${this.path} on the ${this.field.listKey} list`;
    }

    if (this.config.defaultTo) {
      throw `The Password field type doesn't support the Knex 'defaultTo' config. ` + `Check the config for ${this.path} on the ${this.field.listKey} list`;
    }
  }

  addToTableSchema(table) {
    const column = table.string(this.path, 60);
    if (this.isNotNullable) column.notNullable();
  }

  getQueryConditions(dbPath) {
    // JM: I wonder if performing a regex match here leaks any timing info that
    // could be used to extract information about the hash.. :/
    return {
      [`${this.path}_is_set`]: value => b => value ? b.where(dbPath, '~', bcryptHashRegex.source) : b.where(dbPath, '!~', bcryptHashRegex.source).orWhereNull(dbPath)
    };
  }

}

var index$9 = {
  type: 'Password',
  implementation: Password,
  views: {
    Controller: _join(__dirname, "1cbdcy"),
    Field: _join(__dirname, "3l3ke0"),
    Filter: _join(__dirname, "18x4cqz")
  },
  adapters: {
    mongoose: MongoPasswordInterface,
    knex: KnexPasswordInterface
  }
};

function ownKeys$h(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$h(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$h(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$h(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const MAX_UNIQUE_ATTEMPTS = 100;

const findFirstNonEmptyStringValue = fields => Object.values(fields).find(value => typeof value === 'string' && value);

const generateSlug = valueToSlugify => slugify(valueToSlugify || '');

class SlugImplementation extends Text {
  constructor(path, {
    from,
    generate,
    makeUnique,
    alwaysMakeUnique = false,
    isUnique,
    regenerateOnUpdate = true
  }, {
    listKey
  }) {
    const listAndFieldPath = `${listKey}.${path}`;

    if (typeof regenerateOnUpdate !== 'boolean') {
      throw new Error(`The 'regenerateOnUpdate' option on ${listAndFieldPath} must be true/false`);
    }

    if (typeof alwaysMakeUnique !== 'boolean') {
      throw new Error(`The 'alwaysMakeUnique' option on ${listAndFieldPath} must be true/false`);
    }

    if (from && generate) {
      throw new Error(`Only one of 'from' or 'generate' can be supplied as an option to the Slug field on ${listAndFieldPath}.`);
    }

    let generateFn;
    let makeUniqueFn;

    if (from) {
      if (typeof from !== 'string') {
        if (typeof from === 'function') {
          throw new Error(`A function was specified for the 'from' option on ${listAndFieldPath}, but 'from' exects a string. Did you mean to set the 'generate' option?`);
        }

        throw new Error(`The 'from' option on ${listAndFieldPath} must be a string`);
      }

      generateFn = ({
        resolvedData,
        existingItem
      }) => {
        // Look up fields on the list to ensure a valid field was passed
        if (!this.getListByKey(this.listKey).getFieldByPath(from)) {
          throw new Error(`The field '${from}' does not exist on the list '${listKey}' as specified in the 'from' option of '${listAndFieldPath}'`);
        } // Ensure we generate on a complete object (because `resolvedData` may
        // only be partial)


        return generateSlug(_objectSpread$h(_objectSpread$h({}, existingItem), resolvedData)[from]);
      };
    } else if (!generate) {
      // Set a default `generate` method
      generateFn = ({
        resolvedData,
        existingItem
      }) => {
        // Ensure we generate on a complete object (because `resolvedData` may
        // only be partial)
        const _existingItem$resolve = _objectSpread$h(_objectSpread$h({}, existingItem), resolvedData),
              {
          id,
          name,
          title
        } = _existingItem$resolve,
              fields = _objectWithoutProperties(_existingItem$resolve, ["id", "name", "title"]);

        const valueToSlugify = name || title || findFirstNonEmptyStringValue(fields);

        if (!valueToSlugify) {
          throw new Error('Unable to find a valid field to generate a slug for ${listAndFieldPath}. Please provide a `generate` method.');
        }

        return generateSlug(valueToSlugify);
      };
    } else {
      if (typeof generate !== 'function') {
        throw new Error(`The 'generate' option on ${listAndFieldPath} must be a function, but received ${typeof generate}`);
      } // Wrap the provided generator function in an error handler


      generateFn = async ({
        resolvedData,
        existingItem
      }) => {
        const slug = await generate({
          resolvedData,
          existingItem
        });

        if (typeof slug !== 'string') {
          throw new Error(`${listAndFieldPath}'s 'generate' option resolved with a ${typeof slug}, but expected a string.`);
        }

        return slug;
      };
    }

    if (typeof makeUnique === 'undefined') {
      // Set the default uniqueifying function
      makeUniqueFn = ({
        slug
      }) => `${slug}-${cuid.slug()}`;
    } else {
      if (typeof makeUnique !== 'function') {
        throw new Error(`The 'makeUnique' option on ${listAndFieldPath} must be a function, but received ${typeof makeUnique}`);
      } // Wrap the provided makeUnique function in an error handler


      makeUniqueFn = async ({
        slug,
        previousSlug
      }) => {
        const uniqueifiedSlug = await makeUnique({
          slug,
          previousSlug
        });

        if (typeof uniqueifiedSlug !== 'string') {
          throw new Error(`${listAndFieldPath}'s 'makeUnique' option resolved with a ${typeof uniqueifiedSlug}, but expected a string.`);
        }

        return uniqueifiedSlug;
      };
    }

    const isUniqueCalculated = typeof isUnique === 'undefined' ? true : isUnique;
    super(arguments[0], _objectSpread$h(_objectSpread$h({}, arguments[1]), {}, {
      // Default isUnique to true
      isUnique: isUniqueCalculated
    }), arguments[2]);
    this.isUnique = isUniqueCalculated;
    this.generateFn = generateFn;
    this.makeUnique = makeUniqueFn;
    this.regenerateOnUpdate = regenerateOnUpdate;
    this.alwaysMakeUnique = alwaysMakeUnique;
    this.isOrderable = true;
  }

  async resolveInput({
    resolvedData,
    existingItem,
    actions: {
      query
    }
  }) {
    let slug; // A slug has been passed in

    if (resolvedData[this.path]) {
      // A slug was passed in, so we want to use that.
      // NOTE: This can result in slugs changing if doing an update and the
      // passed-in slug is not unique:
      // 1. Perform a `create` mutation: `createPost(data: { slug:
      //    "hello-world" }) { slug }`.
      //   * Result: `{ slug: "hello-world" }`
      // 2. Perform a second `create` mutation with the same slug: `createPost(data: { slug: "hello-world" }) { id slug }`.
      //   * Result (approximately): `{ id: "1", slug: "hello-world-weer84fs" }`
      // 3. Perform an update to the second item, with the same slug as the first (again): `updatePost(id: "1", data: { slug: "hello-world" }) { id slug }`.
      //   * Result (approximately): `{ id: "1", slug: "hello-world-uyi3lh32" }`
      //   * The slug has changed, even though we passed the same slug in.
      //     This happens because there is no way to know what the previously
      //     passed-in slug was, only the most recently _uniquified_ slug (ie;
      //     `"hello-world-weer84fs"`).
      slug = resolvedData[this.path];
    } else {
      // During a create
      if (!existingItem) {
        // We always generate a new one
        slug = await this.generateFn({
          resolvedData
        });
      } else {
        // During an update
        // There used to be a slug set, and we don't want to forcibly regenerate
        if (!this.regenerateOnUpdate) {
          // So we re-use that existing slug
          // Later, we check for uniqueness against other items, while excluding
          // this one, ensuring this slug stays stable.
          // NOTE: If a slug was not previously set, this _will not_ generate a
          // new one.
          slug = existingItem[this.path];
        } else {
          // Attempt to regenerate the raw slug (before it was passed through
          // `makeUnique`) from existing data
          const existingNonUniqueSlug = await this.generateFn({
            resolvedData: existingItem
          }); // Now generate the new raw slug (it has yet to be passed through
          // `makeUnique`)

          const newNonUniqueSlug = await this.generateFn({
            resolvedData,
            existingItem
          });

          if (existingNonUniqueSlug === newNonUniqueSlug) {
            // If they match, we can re-use the existing, unique slug. Note this
            // will still pass through uniquification, but because we only check
            // uniqueness against _other_ items, and this item already existed,
            // we can assume it will not need re-uniquifying, so passing it
            // through the logic below is ok.
            slug = existingItem[this.path];
          } else {
            // If they don't match, we have to assume some data important to the
            // slug has changed, so we go with the new value, and let it get
            // uniquified later
            slug = newNonUniqueSlug;
          }
        }
      }
    }

    if (!this.isUnique && !this.alwaysMakeUnique) {
      return slug;
    }

    let uniqueSlug = slug;
    let slugIsUnique;
    let makeUniqueAttempts = 0;
    const listAndFieldPath = `${this.listKey}.${this.path}`; // The "all<List>s" query

    const {
      listQueryMetaName,
      whereInputName
    } = this.getListByKey(this.listKey).gqlNames; // A query to find any _other_ items with the same slug

    const queryString = `
      query findDuplicate($where: ${whereInputName}) {
        ${listQueryMetaName}(where: $where) {
          count
        }
      }
    `;

    if (this.alwaysMakeUnique) {
      // Force a uniquification pass over the slug
      uniqueSlug = await this.makeUnique({
        slug,
        previousSlug: uniqueSlug
      });
    } // Repeat until we have a unique slug, or we've tried too many times


    do {
      if (makeUniqueAttempts >= MAX_UNIQUE_ATTEMPTS) {
        throw new Error(`Attempted to generate a unique slug for ${listAndFieldPath}, but failed after too many attempts. If you've passed a custom 'makeUnique' function, ensure it is working correctly`);
      }

      makeUniqueAttempts++; // Check to see if the slug is unique

      const {
        data,
        errors
      } = await query(queryString, {
        variables: {
          where: _objectSpread$h({
            [this.path]: uniqueSlug
          }, existingItem && existingItem.id && {
            id_not_in: [existingItem.id]
          })
        },
        // Access Control may filter out some results, so we wouldn't be
        // retreiving an accurate list of all existing items. Because we add the
        // unique constraint to the field, the database will throw an error if
        // we miss a match and try to insert anyway.
        skipAccessControl: true
      });

      if (errors) {
        throw new Error(`Attempted to generate a unique slug for ${listAndFieldPath}, but failed with an error: ${errors[0].toString()}`);
      }

      const duplicates = data[listQueryMetaName].count; // If there aren't any matches, this slug can be considered unique

      slugIsUnique = duplicates === 0;

      if (!slugIsUnique) {
        // An existinig slug was found, so we try make it unique
        uniqueSlug = await this.makeUnique({
          slug,
          previousSlug: uniqueSlug
        });
      }
    } while (!slugIsUnique);

    return uniqueSlug;
  }

}

const Slug = {
  type: 'Slug',
  implementation: SlugImplementation,
  views: {
    Controller: _join(__dirname, "wneme6"),
    Field: _join(__dirname, "1hkygzc"),
    Filter: _join(__dirname, "1603tj9")
  },
  adapters: {
    knex: KnexTextInterface,
    mongoose: MongoTextInterface
  }
};
var index$a = {
  type: 'Text',
  implementation: Text,
  views: {
    Controller: _join(__dirname, "wneme6"),
    Field: _join(__dirname, "1hkygzc"),
    Filter: _join(__dirname, "1603tj9")
  },
  adapters: {
    mongoose: MongoTextInterface,
    knex: KnexTextInterface
  }
};

function ownKeys$i(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$i(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$i(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$i(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

global.fetch = global.fetch || require('node-fetch');
const defaultTransforms = {
  fm: 'jpg',
  q: 75,
  fit: 'max'
};

function transformUserFromApiToKs5(user, {
  includeId = false
} = {}) {
  return _objectSpread$i(_objectSpread$i({}, includeId && {
    id: user.id
  }), {}, {
    unsplashId: user.id,
    username: user.username,
    name: user.name,
    url: user.links.html,
    portfolioUrl: user.portfolio_url,
    bio: user.bio,
    location: user.location
  });
}

function transformImageFromApiToKs5(image, {
  includeId = false
} = {}) {
  return _objectSpread$i(_objectSpread$i({}, includeId && {
    id: image.id
  }), {}, {
    unsplashId: image.id,
    width: image.width,
    height: image.height,
    color: image.color,
    description: image.description || null,
    alt: image.alt_description || null,
    publicUrl: image.urls.raw,
    user: transformUserFromApiToKs5(image.user, {
      includeId
    })
  });
}

class Unsplash extends Field {
  constructor(_, {
    accessKey,
    secretKey
  }) {
    if (!accessKey) {
      throw new Error('Must provide an accessKey to Unsplash Image Field. See https://unsplash.com/documentation#creating-a-developer-account');
    }

    if (!secretKey) {
      throw new Error('Must provide a secretKey to Unsplash Image Field. See https://unsplash.com/documentation#creating-a-developer-account');
    }

    super(...arguments);
    this.graphQLOutputType = 'UnsplashImage';
    this.unsplash = new UnsplashAPI({
      accessKey,
      secret: secretKey
    });
  }

  gqlOutputFields() {
    return [`${this.path}: ${this.graphQLOutputType}`];
  } // Filter based on Unsplash Image IDs


  gqlQueryInputFields() {
    return [...this.equalityInputFields('String'), ...this.stringInputFields('String'), ...this.inInputFields('String')];
  }

  getGqlAuxTypes() {
    return [`
        # A stripped down set of information about an Unsplash User
        # as returned from the Unsplash API
        type UnsplashUser {
          id: ID
          unsplashId: String
          username: String
          name: String
          # The user's URL on Unsplash
          url: String
          # The user supplied portfolio URL
          portfolioUrl: String
          bio: String
          location: String
        }
      `, `
        # Mirrors the formatting options [Unsplash provides](https://unsplash.com/documentation#dynamically-resizable-images).
        # All options are strings as they ultimately end up in a URL.
        input UnsplashImageFormat {
          w: String
          h: String
          crop: String
          # default: ${defaultTransforms.fm}
          fm: String
          auto: String
          # default: ${defaultTransforms.q}
          q: String
          # default: ${defaultTransforms.fit}
          fit: String
          dpi: String
        }
      `, `
        # Information describing an image as hosted by Unsplash
        # NOTE: The public URLs returned here are Unsplash CDN URLs as per their terms:
        # https://unsplash.com/api-terms
        type ${this.graphQLOutputType} {
          id: ID
          unsplashId: String
          width: Int
          height: Int
          color: String
          # The author-supplied description of this photo
          description: String
          # A description of the photo for use with screen readers
          alt: String
          publicUrl: String
          publicUrlTransformed(transformation: UnsplashImageFormat): String
          user: UnsplashUser
        }
      `, `
        enum UnsplashOrientation {
          landscape
          portrait
          squarish
        }
      `, `
        type UnsplashSearchResults {
          total: Int
          totalPages: Int
          results: [${this.graphQLOutputType}]
        }
      `];
  }

  getGqlAuxQueries() {
    return [`searchUnsplash(query: String!, page: Int, perPage: Int, orientation: UnsplashOrientation, collections: [String]): UnsplashSearchResults`];
  }

  gqlAuxQueryResolvers() {
    return {
      searchUnsplash: async (_, {
        query,
        page,
        perPage,
        orientation,
        collections
      }) => {
        const {
          total,
          total_pages,
          results
        } = await this.unsplash.request({
          url: '/search/photos',
          method: 'GET',
          query: _objectSpread$i(_objectSpread$i(_objectSpread$i(_objectSpread$i({
            query
          }, typeof page !== 'undefined' && {
            page
          }), typeof perPage !== 'undefined' && {
            per_page: perPage
          }), typeof orientation !== 'undefined' && {
            orientation
          }), collections && collections.length && {
            collections: collections.join(',')
          })
        }).then(toJson);
        return {
          total,
          totalPages: total_pages,
          results: results.map(result => this.injectPublicUrlFields(transformImageFromApiToKs5(result, {
            includeId: true
          })))
        };
      }
    };
  }

  injectPublicUrlFields(data) {
    return _objectSpread$i(_objectSpread$i({}, data), {}, {
      // We want the default transformations applied to the regular public
      // URL, so we do a "transformation" here too
      publicUrl: this.publicUrlTransformed(data.publicUrl),
      publicUrlTransformed: ({
        transformation
      }) => this.publicUrlTransformed(data.publicUrl, transformation)
    });
  }

  publicUrlTransformed(publicUrl, transformation) {
    const {
      url,
      query
    } = queryString.parseUrl(publicUrl);
    const transformationQueryString = queryString.stringify(_objectSpread$i(_objectSpread$i(_objectSpread$i({}, defaultTransforms), transformation), query));
    return `${url}${transformationQueryString ? `?${transformationQueryString}` : ''}`;
  } // Called on `User.avatar` for example


  gqlOutputFieldResolvers() {
    return {
      [this.path]: item => {
        const itemValues = item[this.path];

        if (!itemValues) {
          return null;
        }

        return this.injectPublicUrlFields(itemValues);
      }
    };
  }

  async resolveInput({
    resolvedData
  }) {
    const inputId = resolvedData[this.path]; // NOTE: The following two conditions could easily be combined into a
    // single `if (!inputId) return inputId`, but that would lose the nuance of
    // returning `undefined` vs `null`.
    // Premature Optimisers; be ware!

    if (typeof inputId === 'undefined') {
      // Nothing was passed in, so we can bail early.
      return undefined;
    }

    if (inputId === null) {
      // `null` was specifically uploaded, and we should set the field value to
      // null. To do that we... return `null`
      return null;
    }

    const apiResponse = await this.unsplash.photos.getPhoto(inputId).then(toJson); // NOTE: No need to await the response here, it's an event trigger for
    // Unsplash.

    this.unsplash.photos.downloadPhoto(apiResponse); // NOTE: we need to provide an id for the image to avoid issues with Apollo
    // More info here: https://github.com/keystonejs/keystone/pull/1799

    return transformImageFromApiToKs5(apiResponse, {
      includeId: true
    });
  }

  get gqlUpdateInputFields() {
    return [`${this.path}: String`];
  }

  get gqlCreateInputFields() {
    return [`${this.path}: String`];
  }

}

const CommonUnsplashInterface = superclass => class extends superclass {
  getQueryConditions(dbPath) {
    return _objectSpread$i(_objectSpread$i(_objectSpread$i({}, this.equalityConditions(dbPath, ({
      unsplashId
    }) => unsplashId)), this.stringConditions(dbPath, ({
      unsplashId
    }) => unsplashId)), this.inConditions(dbPath, ({
      unsplashId
    }) => unsplashId));
  }

};

class MongoUnsplashInterface extends CommonUnsplashInterface(MongooseFieldAdapter) {
  addToMongooseSchema(schema) {
    const schemaOptions = {
      type: Object
    };
    schema.add({
      [this.path]: this.mergeSchemaOptions(schemaOptions, this.config)
    });
  }

}

class KnexUnsplashInterface extends CommonUnsplashInterface(KnexFieldAdapter) {
  constructor() {
    super(...arguments); // Error rather than ignoring invalid config
    // We totally can index these values, it's just not trivial. See issue #1297

    if (this.config.isUnique || this.config.isIndexed) {
      throw `The Unsplash field type doesn't support indexes on Knex. ` + `Check the config for ${this.path} on the ${this.field.listKey} list`;
    }
  }

  addToTableSchema(table) {
    const column = table.jsonb(this.path);
    if (this.isNotNullable) column.notNullable();
    if (this.defaultTo) column.defaultTo(this.defaultTo);
  }

}

function ownKeys$j(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$j(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$j(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$j(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const RelationshipWrapper$2 = _objectSpread$j(_objectSpread$j({}, RelationshipType), {}, {
  implementation: class extends RelationshipType.implementation {
    async resolveNestedOperations(operations, item, context, ...args) {
      const result = await super.resolveNestedOperations(operations, item, context, ...args);
      context._blockMeta = context._blockMeta || {};
      context._blockMeta[this.listKey] = context._blockMeta[this.listKey] || {};
      context._blockMeta[this.listKey][this.path] = result;
      return result;
    }

  }
});

class UnsplashBlock extends Block {
  constructor({
    accessKey,
    secretKey,
    attribution
  }, {
    fromList,
    joinList,
    createAuxList,
    getListByKey
  }) {
    super(...arguments);
    this.joinList = joinList;

    if (typeof attribution === 'string' && attribution) {
      this.attribution = {
        source: attribution
      };
    } else if (typeof attribution === 'object' && attribution.source) {
      this.attribution = attribution;
    } else {
      throw new Error('The unsplash-image block requires the `attribution` option to be either a string, or object { source<String>, medium<String?> }');
    }

    const auxListKey = `_Block_${fromList}_${this.type}`; // Ensure the list is only instantiated once per server instance.

    let auxList = getListByKey(auxListKey);

    if (!auxList) {
      auxList = createAuxList(auxListKey, {
        fields: {
          image: {
            type: Unsplash$1,
            isRequired: true,
            accessKey,
            secretKey,
            schemaDoc: 'Unsplash image data'
          },
          // Useful for doing reverse lookups such as:
          // - "Get all embeds in this post"
          // - "List all users mentioned in comment"
          from: {
            type: RelationshipType,
            isRequired: true,
            ref: `${joinList}.${this.path}`,
            schemaDoc: 'A reference back to the Slate.js Serialised Document this unsplash image is contained within'
          }
        }
      });
    }

    this.auxList = auxList;
  }

  get type() {
    return 'unsplashImage';
  }

  get path() {
    return pluralize.plural(this.type);
  }

  getFieldDefinitions() {
    return {
      [this.path]: {
        type: RelationshipWrapper$2,
        ref: `${this.auxList.key}.from`,
        many: true,
        schemaDoc: 'Unsplash Images which have been added to the Content field'
      }
    };
  }

  getMutationOperationResults({
    context
  }) {
    return {
      [this.path]: context._blockMeta && context._blockMeta[this.joinList] && context._blockMeta[this.joinList][this.path]
    };
  }

  getAdminViews() {
    return [_join(__dirname, "10cirgn")];
  }

  getViewOptions() {
    return {
      query: `
        unsplashImages {
          id
          image {
            id
            unsplashId
            publicUrl: publicUrlTransformed(transformation: { w: "620" })
            description
            user {
              name
              url
            }
          }
        }
      `,
      attribution: this.attribution
    };
  }

}

var Unsplash$1 = {
  type: 'Unsplash',
  implementation: Unsplash,
  views: {
    Controller: _join(__dirname, "1c59lz8"),
    Field: _join(__dirname, "1mjnj57"),
    Cell: _join(__dirname, "wmn1lu")
  },
  adapters: {
    mongoose: MongoUnsplashInterface,
    knex: KnexUnsplashInterface
  },
  blocks: {
    unsplashImage: UnsplashBlock
  }
};
var index$b = {
  type: 'Url',
  implementation: Text,
  views: {
    Controller: _join(__dirname, "wneme6"),
    Field: _join(__dirname, "os2npx"),
    Filter: _join(__dirname, "1603tj9"),
    Cell: _join(__dirname, "tzatfx")
  },
  adapters: {
    mongoose: MongoTextInterface,
    knex: KnexTextInterface
  }
};

function ownKeys$k(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$k(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$k(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$k(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

class UuidImplementation extends Field {
  constructor(path, {
    caseTo = 'lower'
  }) {
    super(...arguments);

    this.normaliseValue = a => a;

    if (caseTo && caseTo.toString().toLowerCase() === 'upper') {
      this.normaliseValue = a => a.toString().toUpperCase();
    } else if (caseTo && caseTo.toString().toLowerCase() === 'lower') {
      this.normaliseValue = a => a.toString().toLowerCase();
    }

    this.isOrderable = true;
  }

  gqlOutputFields() {
    return [`${this.path}: ID`];
  }

  gqlOutputFieldResolvers() {
    return {
      [`${this.path}`]: item => item[this.path]
    };
  }

  gqlQueryInputFields() {
    return [...this.equalityInputFields('ID'), ...this.inInputFields('ID')];
  }

  get gqlUpdateInputFields() {
    return [`${this.path}: ID`];
  }

  get gqlCreateInputFields() {
    return [`${this.path}: ID`];
  }

}

const validator = a => typeof a === 'string' && /^[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}$/.test(a); // TODO: UUIDs _should_ be stored in Mongo using binary subtype 0x04 but strings are easier; see README.md


class MongoUuidInterface extends MongooseFieldAdapter {
  addToMongooseSchema(schema, mongoose) {
    const schemaOptions = {
      type: mongoose.Schema.Types.String,
      validate: {
        validator: this.buildValidator(validator),
        message: '{VALUE} is not a valid UUID. Must be 8-4-4-4-12 hex format'
      }
    };
    schema.add({
      [this.path]: this.mergeSchemaOptions(schemaOptions, this.config)
    });
  }

  setupHooks({
    addPreSaveHook,
    addPostReadHook
  }) {
    // TODO: Remove the need to dereference the list and field to get the normalise function
    addPreSaveHook(item => {
      // Only run the hook if the item actually contains the field
      // NOTE: Can't use hasOwnProperty here, as the mongoose data object
      // returned isn't a POJO
      if (!(this.path in item)) {
        return item;
      }

      if (item[this.path]) {
        if (typeof item[this.path] === 'string') {
          item[this.path] = this.field.normaliseValue(item[this.path]);
        } else {
          // Should have been caught by the validator??
          throw `Invalid UUID value given for '${this.path}'`;
        }
      } else {
        item[this.path] = null;
      }

      return item;
    });
    addPostReadHook(item => {
      if (item[this.path]) {
        item[this.path] = this.field.normaliseValue(item[this.path]);
      }

      return item;
    });
  }

  getQueryConditions(dbPath) {
    return _objectSpread$k(_objectSpread$k({}, this.equalityConditions(dbPath, this.field.normaliseValue)), this.inConditions(dbPath, this.field.normaliseValue));
  }

}

class KnexUuidInterface extends KnexFieldAdapter {
  constructor() {
    super(...arguments); // TODO: Warning on invalid config for primary keys?

    if (!this.field.isPrimaryKey) {
      this.isUnique = !!this.config.isUnique;
      this.isIndexed = !!this.config.isIndexed && !this.config.isUnique;
    }
  }

  addToTableSchema(table) {
    const column = table.uuid(this.path); // Fair to say primary keys are always non-nullable and uniqueness is implied by primary()

    if (this.field.isPrimaryKey) {
      column.primary().notNullable();
    } else {
      if (this.isUnique) column.unique();else if (this.isIndexed) column.index();
      if (this.isNotNullable) column.notNullable();
    }

    if (this.defaultTo) column.defaultTo(this.defaultTo);
  }

  addToForeignTableSchema(table, {
    path,
    isUnique,
    isIndexed,
    isNotNullable
  }) {
    if (!this.field.isPrimaryKey) {
      throw `Can't create foreign key '${path}' on table "${table._tableName}"; ` + `'${this.path}' on list '${this.field.listKey}' as is not the primary key.`;
    }

    const column = table.uuid(path);
    if (isUnique) column.unique();else if (isIndexed) column.index();
    if (isNotNullable) column.notNullable();
  }

  getQueryConditions(dbPath) {
    return _objectSpread$k(_objectSpread$k({}, this.equalityConditions(dbPath, this.field.normaliseValue)), this.inConditions(dbPath, this.field.normaliseValue));
  }

}

const Uuid = {
  type: 'Uuid',
  implementation: UuidImplementation,
  views: {
    Controller: _join(__dirname, "1qy9sro"),
    Field: _join(__dirname, "14e1hhi"),
    Filter: _join(__dirname, "13nbhhd")
  },
  adapters: {
    knex: KnexUuidInterface,
    mongoose: MongoUuidInterface
  },
  primaryKeyDefaults: {
    knex: {
      getConfig: client => {
        if (client === 'postgres') {
          return {
            type: Uuid,
            knexOptions: {
              defaultTo: knex => knex.raw('gen_random_uuid()')
            }
          };
        }

        throw `The Uuid field type doesn't provide a default primary key field configuration for the ` + `'${client}' knex client. You'll need to supply your own 'id' field for each list or use a ` + `different field type for your ids (eg '@keystonejs/fields-auto-increment').`;
      }
    },
    mongoose: {
      getConfig: () => {
        throw `The Uuid field type doesn't provide a default primary key field configuration for mongoose. ` + `You'll need to supply your own 'id' field for each list or use a different field type for your ` + `ids (eg '@keystonejs/fields-mongoid').`;
      }
    }
  }
};

function ownKeys$l(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$l(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$l(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$l(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

class Virtual extends Field {
  constructor(path, {
    resolver,
    graphQLReturnType = 'String',
    graphQLReturnFragment = '',
    extendGraphQLTypes = []
  }) {
    super(...arguments);
    this.resolver = resolver;
    this.graphQLReturnType = graphQLReturnType;
    this.graphQLReturnFragment = graphQLReturnFragment;
    this.extendGraphQLTypes = extendGraphQLTypes;
  }

  gqlOutputFields() {
    return [`${this.path}: ${this.graphQLReturnType}`];
  }

  getGqlAuxTypes() {
    return this.extendGraphQLTypes;
  }

  gqlOutputFieldResolvers() {
    return {
      [`${this.path}`]: this.resolver
    };
  }

  gqlQueryInputFields() {
    return [];
  }

  extendAdminMeta(meta) {
    return _objectSpread$l(_objectSpread$l({}, meta), {}, {
      graphQLSelection: this.graphQLReturnFragment,
      isReadOnly: true
    });
  }

  parseFieldAccess(args) {
    const parsedAccess = parseFieldAccess(args);
    const fieldDefaults = {
      create: false,
      update: false,
      delete: false
    };
    return Object.keys(parsedAccess).reduce((prev, schemaName) => {
      prev[schemaName] = _objectSpread$l(_objectSpread$l({}, fieldDefaults), {}, {
        read: parsedAccess[schemaName].read
      });
      return prev;
    }, {});
  }

}

const CommonTextInterface$1 = superclass => class extends superclass {
  getQueryConditions() {
    return {};
  }

};

class MongoVirtualInterface extends CommonTextInterface$1(MongooseFieldAdapter) {
  constructor() {
    super(...arguments);
    this.realKeys = [];
  }

  addToMongooseSchema() {}

}

class KnexVirtualInterface extends CommonTextInterface$1(KnexFieldAdapter) {
  constructor() {
    super(...arguments);
    this.realKeys = [];
  }

  addToTableSchema() {}

}

var index$c = {
  type: 'Virtual',
  implementation: Virtual,
  views: {
    Controller: _join(__dirname, "1u1f5ml"),
    Cell: _join(__dirname, "im20a2"),
    Field: _join(__dirname, "1lbva73"),
    Filter: _join(__dirname, "1pjmpnt")
  },
  adapters: {
    mongoose: MongoVirtualInterface,
    knex: KnexVirtualInterface
  }
};
export { index as CalendarDay, index$1 as Checkbox, CloudinaryImage$1 as CloudinaryImage, index$2 as Color, index$3 as DateTime, index$4 as Decimal, index$5 as File, index$6 as Float, Field as Implementation, index$7 as Integer, index$8 as Location, OEmbed$1 as OEmbed, index$9 as Password, RelationshipType as Relationship, SelectType as Select, Slug, index$a as Text, Unsplash$1 as Unsplash, index$b as Url, Uuid, index$c as Virtual };
