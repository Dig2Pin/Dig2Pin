"use strict";

function _interopDefault(ex) {
  return ex && "object" == typeof ex && "default" in ex ? ex.default : ex;
}

Object.defineProperty(exports, "__esModule", {
  value: !0
});

var _defineProperty = _interopDefault(require("@babel/runtime/helpers/defineProperty")), pLazy = _interopDefault(require("p-lazy")), pReflect = _interopDefault(require("p-reflect")), isPromise = _interopDefault(require("p-is-promise")), semver = _interopDefault(require("semver"));

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

const noop = x => x, identity = noop, getType = thing => Object.prototype.toString.call(thing).replace(/\[object (.*)\]/, "$1"), escapeRegExp = str => (str || "").replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"), mapKeys = (obj, func) => Object.entries(obj).reduce((acc, [key, value]) => _objectSpread(_objectSpread({}, acc), {}, {
  [key]: func(value, key, obj)
}), {}), mapKeyNames = (obj, func) => Object.entries(obj).reduce((acc, [key, value]) => _objectSpread(_objectSpread({}, acc), {}, {
  [func(key, value, obj)]: value
}), {}), resolveAllKeys = async obj => {
  const returnValue = {}, errors = {}, allPromises = Object.keys(obj).map(key => pReflect(obj[key]).then(val => (val.isFulfilled ? returnValue[key] = val.value : val.isRejected && (errors[key] = val.reason), 
  val))), results = await Promise.all(allPromises);
  if (Object.keys(errors).length) {
    const firstError = results.find(({isRejected: isRejected}) => isRejected).reason, error = new Error(firstError.message || firstError.toString());
    throw error.errors = errors, error;
  }
  return returnValue;
}, unique = arr => [ ...new Set(arr) ], intersection = (array1, array2) => unique(array1.filter(value => array2.includes(value))), pick = (obj, keys) => keys.reduce((acc, key) => key in obj ? _objectSpread(_objectSpread({}, acc), {}, {
  [key]: obj[key]
}) : acc, {}), omitBy = (obj, func) => pick(obj, Object.keys(obj).filter(value => !func(value))), omit = (obj, keys) => omitBy(obj, value => keys.includes(value)), objMerge = objs => objs.reduce((acc, obj) => _objectSpread(_objectSpread({}, acc), obj), {}), defaultObj = (keys, val) => keys.reduce((acc, key) => _objectSpread(_objectSpread({}, acc), {}, {
  [key]: val
}), {}), filterValues = (obj, predicate) => Object.entries(obj).reduce((acc, [key, value]) => predicate(value) ? _objectSpread(_objectSpread({}, acc), {}, {
  [key]: value
}) : acc, {}), arrayToObject = (objs, keyedBy, mapFn = (i => i)) => objs.reduce((acc, obj) => _objectSpread(_objectSpread({}, acc), {}, {
  [obj[keyedBy]]: mapFn(obj)
}), {}), flatten = arr => Array.prototype.concat(...arr), flatMap = (arr, fn = identity) => flatten(arr.map(fn)), zipObj = obj => Object.values(obj)[0].map((_, i) => Object.keys(obj).reduce((acc, k) => _objectSpread(_objectSpread({}, acc), {}, {
  [k]: obj[k][i]
}), {})), compose = fns => o => fns.reduce((acc, fn) => fn(acc), o), mergeWhereClause = (queryArgs, whereClauseToMergeIn) => {
  if ("Object" !== getType(whereClauseToMergeIn) || 0 === Object.keys(whereClauseToMergeIn).length) return queryArgs;
  const mergedQueryArgs = queryArgs.where && Object.keys(queryArgs.where).length > 0 ? {
    AND: [ queryArgs.where, whereClauseToMergeIn ]
  } : whereClauseToMergeIn;
  return _objectSpread(_objectSpread({}, queryArgs), {}, {
    where: mergedQueryArgs
  });
}, createLazyDeferred = () => {
  let state, resolvedWith, rejectedWith, resolveCallback, rejectCallback;
  return {
    promise: new pLazy((resolve, reject) => {
      "resolved" === state ? resolve(resolvedWith) : "rejected" === state ? reject(rejectedWith) : (resolveCallback = resolve, 
      rejectCallback = reject);
    }),
    resolve: val => {
      resolveCallback ? resolveCallback(val) : (resolvedWith = val, state = "resolved");
    },
    reject: error => {
      rejectCallback ? rejectCallback(error) : (rejectedWith = error, state = "rejected");
    }
  };
}, captureSuspensePromises = executors => {
  const values = [], promises = executors.map(executor => {
    try {
      values.push(executor());
    } catch (loadingPromiseOrError) {
      if (!isPromise(loadingPromiseOrError)) throw loadingPromiseOrError;
      return loadingPromiseOrError;
    }
  }).filter(Boolean);
  if (promises.length) throw Promise.all(promises);
  return values;
}, countArrays = obj => Object.values(obj).reduce((total, items) => total + (items ? items.length : 0), 0), versionGreaterOrEqualTo = (comp, base) => {
  const parseVersion = input => ("object" == typeof input && (input = input.join(".")), 
  semver.coerce(input)), v1 = parseVersion(comp), v2 = parseVersion(base);
  return semver.gte(v1, v2);
}, upcase = str => str.substr(0, 1).toUpperCase() + str.substr(1), asyncForEach = async (array, callback) => {
  for (let index = 0; index < array.length; index++) await callback(array[index], index, array);
};

exports.arrayToObject = arrayToObject, exports.asyncForEach = asyncForEach, exports.captureSuspensePromises = captureSuspensePromises, 
exports.compose = compose, exports.countArrays = countArrays, exports.createLazyDeferred = createLazyDeferred, 
exports.defaultObj = defaultObj, exports.escapeRegExp = escapeRegExp, exports.filterValues = filterValues, 
exports.flatMap = flatMap, exports.flatten = flatten, exports.getType = getType, 
exports.identity = identity, exports.intersection = intersection, exports.mapKeyNames = mapKeyNames, 
exports.mapKeys = mapKeys, exports.mergeWhereClause = mergeWhereClause, exports.noop = noop, 
exports.objMerge = objMerge, exports.omit = omit, exports.omitBy = omitBy, exports.pick = pick, 
exports.resolveAllKeys = resolveAllKeys, exports.unique = unique, exports.upcase = upcase, 
exports.versionGreaterOrEqualTo = versionGreaterOrEqualTo, exports.zipObj = zipObj;
