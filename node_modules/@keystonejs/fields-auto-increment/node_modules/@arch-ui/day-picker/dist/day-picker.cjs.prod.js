"use strict";

function _interopDefault(ex) {
  return ex && "object" == typeof ex && "default" in ex ? ex.default : ex;
}

Object.defineProperty(exports, "__esModule", {
  value: !0
});

var _extends = _interopDefault(require("@babel/runtime/helpers/extends")), core = require("@emotion/core"), styled = _interopDefault(require("@emotion/styled")), dateFns = require("date-fns"), reactWindow = require("react-window"), icons = require("@arch-ui/icons"), React = require("react"), React__default = _interopDefault(React), theme = require("@arch-ui/theme"), typography = require("@arch-ui/typography");

require("intersection-observer");

var input = require("@arch-ui/input"), Select = _interopDefault(require("@arch-ui/select")), _defineProperty = _interopDefault(require("@babel/runtime/helpers/defineProperty")), _objectWithoutProperties = _interopDefault(require("@babel/runtime/helpers/objectWithoutProperties")), chrono = _interopDefault(require("chrono-node")), moment = _interopDefault(require("moment"));

const yearRange = (from, to) => {
  const years = [];
  let year = from;
  for (;year <= to; ) years.push(year++);
  return years;
}, months = Array.from({
  length: 12
}, (_, i) => i);

function createDayObject(dateValue) {
  return {
    dateValue: dateValue,
    label: dateFns.getDate(dateValue)
  };
}

function getWeeksInMonth(date) {
  const weekOptions = {
    weekStartsOn: 0
  }, firstDayOfMonth = dateFns.startOfMonth(date), firstDayOfFirstWeek = dateFns.startOfWeek(firstDayOfMonth, weekOptions), lastDayOfFirstWeek = dateFns.endOfWeek(firstDayOfMonth, weekOptions), getWeeks = (startDay, endDay, weekArray) => {
    const weeks = [ ...weekArray, dateFns.eachDayOfInterval({
      start: startDay,
      end: endDay
    }).map(createDayObject) ], nextWeek = dateFns.addWeeks(startDay, 1), firstDayNextWeek = dateFns.startOfWeek(nextWeek, weekOptions), lastDayNextWeek = dateFns.endOfWeek(nextWeek, weekOptions);
    return dateFns.isSameMonth(firstDayNextWeek, date) ? getWeeks(firstDayNextWeek, lastDayNextWeek, weeks) : weeks;
  };
  return getWeeks(firstDayOfFirstWeek, lastDayOfFirstWeek, []);
}

function isNumberInRange(num, start, end) {
  return num >= start && num <= end;
}

function usePrevious(value) {
  const ref = React.useRef(value);
  return React.useEffect(() => {
    ref.current = value;
  }), ref.current;
}

const monthOptions = months.map((month, i) => core.jsx("option", {
  key: i,
  value: i
}, dateFns.format(dateFns.setMonth(new Date, month), "LLL"))), SelectMonth = React.memo(({onChange: onChange, month: month}) => core.jsx("select", {
  id: "ks-select-month",
  onChange: event => {
    onChange(Number(event.target.value));
  },
  value: month
}, monthOptions)), SelectYear = React.memo(({onChange: onChange, year: year, yearRangeFrom: yearRangeFrom, yearRangeTo: yearRangeTo, yearPickerType: yearPickerType}) => {
  const years = yearRange(yearRangeFrom, yearRangeTo), [internalValue, setInternalValue] = React.useState(year), previousYearProp = usePrevious(year);
  React.useEffect(() => {
    previousYearProp !== year && setInternalValue(year);
  }, [ previousYearProp, year, setInternalValue ]);
  const handleChange = event => {
    const value = Number(event.target.value);
    setInternalValue(value), isNumberInRange(value, yearRangeFrom, yearRangeTo) && onChange(value);
  };
  return years.length > 50 && "auto" === yearPickerType || "input" === yearPickerType ? core.jsx("input", {
    id: "ks-input-year",
    type: "number",
    min: yearRangeFrom,
    max: yearRangeTo,
    onChange: handleChange,
    value: internalValue
  }) : core.jsx("select", {
    id: "ks-select-year",
    onChange: handleChange,
    value: internalValue
  }, years.map((yearOption, i) => core.jsx("option", {
    key: i,
    value: yearOption
  }, yearOption)));
}), WeekRow = styled.div({
  display: "flex"
}), WeekLabels = styled(WeekRow)({
  color: theme.colors.N40,
  fontSize: "0.65rem",
  fontWeight: 500,
  textTransform: "uppercase"
}), Day = styled.div(({disabled: disabled, isInteractive: isInteractive, isSelected: isSelected, isToday: isToday}) => {
  let textColor;
  return isToday && (textColor = theme.colors.danger), disabled && (textColor = theme.colors.N40), 
  isSelected && (textColor = "white"), {
    alignItems: "center",
    backgroundColor: isSelected ? theme.colors.primary : null,
    borderRadius: theme.borderRadius,
    color: textColor,
    cursor: isInteractive ? "pointer" : "default",
    display: "flex",
    flexDirection: "column",
    fontWeight: isSelected || isToday ? "bold" : null,
    flexBasis: "calc(100% / 7)",
    padding: "0.5rem",
    textAlign: "center",
    width: "calc(100% / 7)",
    ":hover": {
      backgroundColor: isInteractive && !isSelected ? theme.colors.B.L90 : null,
      color: !isInteractive || isSelected || isToday ? null : theme.colors.B.D40
    },
    ":active": {
      backgroundColor: isInteractive && !isSelected ? theme.colors.B.L80 : null
    }
  };
}), TodayMarker = styled.div(({isSelected: isSelected}) => ({
  backgroundColor: isSelected ? "white" : theme.colors.danger,
  borderRadius: 4,
  height: 2,
  marginBottom: -4,
  marginTop: 2,
  width: "1em"
})), Month = React.memo(({style: style, index: index, data: data}) => {
  const {items: items, selectedDate: selectedDate, onSelectedChange: onSelectedChange, observer: observer} = data, ref = React.useRef(null);
  React.useEffect(() => {
    const node = ref.current;
    if (null !== node) return observer.observe(node), () => observer.unobserve(node);
  }, [ observer ]);
  const {weeks: weeks, month: month, year: year} = items[index];
  return core.jsx("div", {
    ref: ref,
    "data-index": index,
    id: `ks-month-${month}-${year}`,
    style: style
  }, core.jsx(MonthHeader, {
    month: month,
    year: year
  }), weeks.map((week, i) => core.jsx(WeekRow, {
    key: i
  }, week.map(day => {
    const date = new Date(year, month, 3), disabled = !dateFns.isSameMonth(date, day.dateValue), isSelected = !disabled && null !== selectedDate && dateFns.isEqual(selectedDate, day.dateValue), isToday = dateFns.isToday(day.dateValue);
    return core.jsx(Day, {
      id: `ks-day-${day.label}-${month}-${year}`,
      key: day.label,
      disabled: disabled,
      onClick: disabled ? null : () => onSelectedChange(day.dateValue),
      isInteractive: !disabled,
      isSelected: isSelected,
      isToday: isToday
    }, day.label, isToday ? core.jsx(TodayMarker, {
      isSelected: isSelected
    }) : null);
  }))));
}), readableMonths = months.map(month => dateFns.format(dateFns.setMonth(new Date, month), "LLLL")), MonthHeader = React.memo(({month: month, year: year}) => core.jsx("div", {
  css: {
    position: "sticky",
    top: 0,
    width: "100%",
    backgroundColor: "#fff"
  }
}, core.jsx("div", {
  css: {
    paddingTop: 4,
    paddingBottom: 4,
    border: `1px ${theme.colors.N60} solid`,
    borderLeft: 0,
    borderRight: 0,
    display: "flex",
    justifyContent: "space-between",
    paddingRight: 12
  }
}, core.jsx("span", {
  css: {
    color: theme.colors.N60
  }
}, readableMonths[month]), core.jsx("span", {
  css: {
    color: theme.colors.N60
  }
}, year)))), Wrapper = styled.div({
  fontSize: "0.85rem"
}), Header = styled.div({
  alignItems: "center",
  display: "flex",
  justifyContent: "space-between"
}), HeaderButton = props => core.jsx("button", _extends({
  type: "button",
  css: {
    background: "none",
    borderRadius: theme.borderRadius,
    border: "none",
    cursor: "pointer",
    padding: "0.5rem 0.75rem",
    outline: "none",
    ":hover": {
      backgroundColor: theme.colors.N05
    },
    ":active": {
      backgroundColor: theme.colors.N10
    }
  }
}, props));

let DAY_HEIGHT = 32.5;

function scrollToDate(date, yearRangeFrom, yearRangeTo, list) {
  if (null !== list) {
    const index = 12 * (dateFns.getYear(date) - yearRangeFrom) + date.getMonth();
    list.scrollToItem(index, "start");
  }
}

let weekLabels = core.jsx(WeekLabels, null, [ ...new Array(7) ].map((_, day) => dateFns.format(dateFns.setDay(new Date, day), "iii")).map(d => core.jsx(Day, {
  key: d
}, d)));

const DayPicker = ({yearRangeFrom: yearRangeFrom = dateFns.getYear(new Date) - 100, yearRangeTo: yearRangeTo = dateFns.getYear(new Date), yearPickerType: yearPickerType = "auto", startCurrentDateAt: startCurrentDateAt, selectedDate: selectedDate, onSelectedChange: onSelectedChange}) => {
  const listRef = React.useRef(null);
  if (!isNumberInRange(startCurrentDateAt.getFullYear(), yearRangeFrom, yearRangeTo)) {
    let date = new Date;
    date.setFullYear(yearRangeTo), startCurrentDateAt = dateFns.endOfYear(date);
  }
  const [date, setDate] = React.useState(startCurrentDateAt), shouldChangeScrollPositionRef = React.useRef(!0), controlledSetDate = React.useCallback(newDate => {
    shouldChangeScrollPositionRef.current = !0, setDate(newDate);
  }, [ shouldChangeScrollPositionRef, setDate ]);
  React.useLayoutEffect(() => {
    shouldChangeScrollPositionRef.current && (scrollToDate(date, yearRangeFrom, yearRangeTo, listRef.current), 
    shouldChangeScrollPositionRef.current = !1);
  }, [ date, yearRangeFrom, yearRangeTo, listRef ]);
  const years = React.useMemo(() => yearRange(yearRangeFrom, yearRangeTo), [ yearRangeFrom, yearRangeTo ]), items = React.useMemo(() => {
    const _items = [];
    return years.forEach(year => {
      months.forEach(month => {
        _items.push({
          year: year,
          month: month,
          weeks: getWeeksInMonth(new Date(year, month, 1))
        });
      });
    }), _items;
  }, [ years ]), currentIndex = 12 * (date.getFullYear() - yearRangeFrom) + date.getMonth(), canGoNextMonth = currentIndex < items.length - 1, canGoPreviousMonth = currentIndex > 0, observer = React.useMemo(() => new IntersectionObserver(entries => {
    const filteredEntries = entries.filter(value => value.isIntersecting).sort((a, b) => a.intersectionRatio > b.intersectionRatio ? -1 : 1);
    if (0 !== filteredEntries.length) {
      let index = Number(filteredEntries[0].target.getAttribute("data-index")), item = items[index];
      setDate(new Date(item.year, item.month, 1));
    }
  }, {
    threshold: .6
  }), [ items ]);
  return core.jsx(Wrapper, null, core.jsx(Header, null, React.useMemo(() => core.jsx(HeaderButton, {
    disabled: !canGoPreviousMonth,
    onClick: () => {
      controlledSetDate(currentDate => dateFns.subMonths(currentDate, 1));
    }
  }, core.jsx(icons.ChevronLeftIcon, null), core.jsx(typography.A11yText, null, "Previous Month")), [ controlledSetDate, canGoPreviousMonth ]), core.jsx(SelectMonth, {
    onChange: React.useCallback(month => {
      controlledSetDate(currentDate => dateFns.setMonth(currentDate, month));
    }, [ controlledSetDate ]),
    month: date.getMonth()
  }), core.jsx(SelectYear, {
    year: dateFns.getYear(date),
    onChange: React.useCallback(year => {
      controlledSetDate(currentDate => dateFns.setYear(currentDate, year));
    }, [ controlledSetDate ]),
    yearRangeFrom: yearRangeFrom,
    yearRangeTo: yearRangeTo,
    yearPickerType: yearPickerType
  }), React.useMemo(() => core.jsx(HeaderButton, {
    disabled: !canGoNextMonth,
    onClick: () => {
      controlledSetDate(currentDate => dateFns.addMonths(currentDate, 1));
    }
  }, core.jsx(icons.ChevronRightIcon, null), core.jsx(typography.A11yText, null, "Next Month")), [ controlledSetDate, canGoNextMonth ])), core.jsx("div", null, weekLabels, core.jsx(reactWindow.VariableSizeList, {
    ref: listRef,
    itemSize: React.useCallback(index => {
      const {weeks: weeks} = items[index];
      return weeks.length * DAY_HEIGHT + 26.5;
    }, [ items ]),
    itemData: React.useMemo(() => ({
      items: items,
      selectedDate: selectedDate,
      onSelectedChange: onSelectedChange,
      observer: observer
    }), [ items, selectedDate, onSelectedChange, observer ]),
    height: 6 * DAY_HEIGHT + 26.5,
    itemCount: 12 * years.length,
    width: "100%"
  }, Month)));
}, options = [ "-12", "-11", "-10", "-09", "-08", "-07", "-06", "-05", "-04", "-03", "-02", "-01", "+00", "+01", "+02", "+03", "+04", "+05", "+06", "+07", "+08", "+09", "+10", "+11", "+12", "+13", "+14" ].map(o => ({
  value: `${o}:00`,
  label: `${o}:00`
})), DayTimePicker = props => {
  const {date: date, time: time, offset: offset, htmlID: htmlID, autoFocus: autoFocus, isDisabled: isDisabled} = props, {handleDayChange: handleDayChange, handleTimeChange: handleTimeChange, handleOffsetChange: handleOffsetChange, yearRangeFrom: yearRangeFrom, yearRangeTo: yearRangeTo, yearPickerType: yearPickerType} = props, TODAY = new Date;
  return React.createElement("div", {
    id: htmlID
  }, React.createElement(DayPicker, {
    autoFocus: autoFocus,
    onSelectedChange: handleDayChange,
    yearRangeFrom: yearRangeFrom,
    yearRangeTo: yearRangeTo,
    yearPickerType: yearPickerType,
    startCurrentDateAt: date ? dateFns.parseISO(date) : TODAY,
    selectedDate: date ? dateFns.parseISO(date) : null
  }), React.createElement(input.Input, {
    type: "time",
    name: "time-picker",
    value: time,
    onChange: handleTimeChange,
    disabled: isDisabled || !1,
    id: `${htmlID}-time`
  }), React.createElement(Select, {
    value: options.find(option => option.value === offset),
    options: options,
    onChange: ({value: value}) => {
      handleOffsetChange(value);
    },
    id: `${htmlID}-offset`
  }));
};

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

const TextDayPicker = React.forwardRef((_ref, ref) => {
  let {date: date = "", onChange: onChange, format: displayFormat = "do MMMM yyyy"} = _ref, props = _objectWithoutProperties(_ref, [ "date", "onChange", "format" ]);
  const formatDate = newDate => newDate ? dateFns.format(dateFns.parseISO(newDate), displayFormat) : "", [isEditing, setIsEditing] = React.useState(!1), [value, setValue] = React.useState({
    raw: date,
    formatted: formatDate(date)
  }), parseCache = React.useRef();
  React.useEffect(() => {
    const parsedDate = chrono.parseDate(value.raw), isoDate = parsedDate ? dateFns.formatISO(parsedDate, {
      representation: "date"
    }) : null;
    onChange(isoDate), parseCache.current = isoDate;
  }, [ value.raw ]);
  return React__default.createElement(input.Input, _extends({
    ref: ref,
    value: isEditing ? value.raw : value.formatted,
    placeholder: "Enter a date...",
    onFocus: () => {
      setIsEditing(!0);
    },
    onBlur: () => {
      setIsEditing(!1);
      const raw = parseCache.current;
      setValue(raw ? {
        raw: raw,
        formatted: formatDate(raw)
      } : {
        raw: "",
        formatted: ""
      });
    },
    onChange: ({target: {value: raw}}) => {
      setValue(oldValue => _objectSpread(_objectSpread({}, oldValue), {}, {
        raw: raw
      }));
    }
  }, props));
});

let TextDayTimePicker = _ref => {
  let {date: date, onChange: onChange} = _ref, props = _objectWithoutProperties(_ref, [ "date", "onChange" ]), [value, setValue] = React.useState(""), ref = React.useRef(null);
  return React.useEffect(() => {
    setValue(formatDateTime(date));
  }, [ date ]), core.jsx(input.Input, _extends({
    value: value,
    ref: ref,
    placeholder: "Enter a date and time...",
    onBlur: () => {
      let parsedDate = parseDate(value);
      onChange(parsedDate), setValue(formatDateTime(parsedDate));
    },
    onChange: event => {
      setValue(event.target.value);
    }
  }, props));
};

function formatDateTime(date) {
  return date ? moment.parseZone(date).format("h:mm A Do MMMM YYYY Z") : "";
}

function parseDate(value) {
  let [parsedDate] = chrono.parse(value);
  return void 0 === parsedDate ? null : parsedDateToMoment(parsedDate).toISOString(!0);
}

function parsedDateToMoment(parsedDate) {
  let dateMoment = moment(), currentTimezoneOffset = moment().utcOffset(), {start: start} = parsedDate;
  dateMoment.set("year", start.get("year")), dateMoment.set("month", start.get("month") - 1), 
  dateMoment.set("date", start.get("day")), dateMoment.set("hour", start.get("hour")), 
  dateMoment.set("minute", start.get("minute")), dateMoment.set("second", start.get("second")), 
  dateMoment.set("millisecond", start.get("millisecond"));
  let targetTimezoneOffset = void 0 !== start.get("timezoneOffset") ? start.get("timezoneOffset") : currentTimezoneOffset;
  return dateMoment.utcOffset(targetTimezoneOffset, !0), dateMoment;
}

exports.DayPicker = DayPicker, exports.DayTimePicker = DayTimePicker, exports.TextDayPicker = TextDayPicker, 
exports.TextDayTimePicker = TextDayTimePicker;
