import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import '@babel/runtime/helpers/esm/objectWithoutProperties';
import { jsx } from '@emotion/core';
import { FieldContainer, FieldLabel, FieldDescription, FieldInput } from '@arch-ui/fields';
import { Fragment } from 'react';
import '@babel/runtime/helpers/esm/extends';
import '@arch-ui/select';
import { gridSize } from '@arch-ui/theme';
import { useQuery } from '@apollo/react-hooks';
import gql from 'graphql-tag';
import { PersonIcon, LinkExternalIcon, PlusIcon } from '@arch-ui/icons';
import { IconButton } from '@arch-ui/button';
import Tooltip from '@arch-ui/tooltip';
import 'react-select';
import 'intersection-observer';
import { R as RelationshipSelect } from './RelationshipSelect-cd3e6aaf.esm.js';
import { ListProvider, useList, CreateItemModal } from '@keystonejs/app-admin-ui/components';

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const MAX_IDS_IN_FILTER = 100;

function SetAsCurrentUser({
  listKey,
  value,
  onAddUser,
  many
}) {
  const path = 'authenticated' + listKey;
  const {
    data
  } = useQuery(gql`
    query User {
      ${path} {
        _label_
        id
      }
    }
  `);

  if (data && data[path]) {
    const userId = data[path].id;

    if (value !== null && (many ? value.some(item => item.id === userId) : value.id === userId)) {
      return null;
    }

    const label = `${many ? 'Add' : 'Set as'} ${data[path]._label_}`;
    return jsx(Tooltip, {
      placement: "top",
      content: label
    }, ref => jsx(IconButton, {
      css: {
        marginLeft: gridSize
      },
      variant: "ghost",
      ref: ref,
      onClick: () => {
        onAddUser(data[path]);
      },
      icon: PersonIcon,
      "aria-label": label
    }));
  }

  return null;
}

function LinkToRelatedItems({
  field,
  value
}) {
  const {
    many
  } = field.config;
  const {
    adminPath
  } = field;
  const {
    path
  } = field.getRefList();
  let isDisabled = false;
  let label;
  let link = `${adminPath}/${path}`;

  if (many) {
    label = 'View List of Related Items';

    if (!value.length) {
      isDisabled = true;
    } // What happens when there are 10,000 ids? The URL would be too
    // big, so we arbitrarily limit it to the first 100


    link = `${link}?!id_in="${value.slice(0, MAX_IDS_IN_FILTER).map(({
      id
    }) => id).join(',')}"`;
  } else {
    label = 'View Item Details';

    if (!value) {
      isDisabled = true;
    } else {
      link = `${link}/${value.id}`;
    }
  }

  return jsx(Tooltip, {
    placement: "top",
    content: label
  }, ref => jsx(IconButton, {
    ref: ref,
    icon: LinkExternalIcon,
    "aria-label": label,
    variant: "ghost",
    css: {
      marginLeft: gridSize
    },
    target: "_blank",
    to: link,
    isDisabled: isDisabled
  }));
}

function CreateAndAddItem({
  field,
  item,
  onCreate
}) {
  const {
    list,
    openCreateItemModal
  } = useList();
  let relatedList = field.getRefList();
  let label = `Create and add ${relatedList.singular}`;
  let prefillData;

  if (item && item.id) {
    prefillData = relatedList.fields // Find relationships on the refList which have a back link to this
    // Relationship field
    .filter(relatedField => relatedField.type === 'Relationship' && relatedField.config.ref === list.key && relatedField.config.refFieldPath === field.path) // And convert it into an object of data to prefill the form with
    .reduce((memo, prefillField) => {
      const prefill = {
        _label_: item._label_ || '<link to parent>',
        id: item.id
      };
      return _objectSpread(_objectSpread({}, memo), {}, {
        [prefillField.path]: prefillField.config.many ? [prefill] : prefill
      });
    }, {});
  }

  return jsx(Fragment, null, jsx(Tooltip, {
    placement: "top",
    content: label
  }, ref => {
    return jsx(IconButton, {
      ref: ref,
      onClick: openCreateItemModal,
      icon: PlusIcon,
      "aria-label": label,
      variant: "ghost",
      css: {
        marginLeft: gridSize
      }
    });
  }), jsx(CreateItemModal, {
    prefillData: prefillData,
    onCreate: ({
      data
    }) => {
      onCreate(data[relatedList.gqlNames.createMutationName]);
    }
  }));
}

const RelationshipField = ({
  autoFocus,
  field,
  value,
  renderContext,
  errors,
  onChange,
  item,
  list
}) => {
  const handleChange = option => {
    const {
      many
    } = field.config;

    if (many) {
      onChange(option ? option.map(i => i.value) : []);
    } else {
      onChange(option ? option.value : null);
    }
  };

  const {
    many,
    ref
  } = field.config;
  const {
    authStrategy
  } = field;
  const htmlID = `ks-input-${field.path}`;
  const relatedList = field.getRefList();
  return jsx(FieldContainer, null, jsx(FieldLabel, {
    htmlFor: htmlID,
    field: field,
    errors: errors
  }), jsx(FieldDescription, {
    text: field.adminDoc
  }), jsx(FieldInput, null, jsx("div", {
    css: {
      flex: 1
    }
  }, jsx(RelationshipSelect, {
    autoFocus: autoFocus,
    isMulti: many,
    field: field,
    value: value,
    errors: errors,
    renderContext: renderContext,
    htmlID: htmlID,
    onChange: handleChange
  })), jsx(ListProvider, {
    list: relatedList
  }, jsx(CreateAndAddItem, {
    onCreate: item => {
      onChange(many ? (value || []).concat(item) : item);
    },
    field: field,
    item: item,
    list: list
  })), authStrategy && ref === authStrategy.listKey && jsx(SetAsCurrentUser, {
    many: many,
    onAddUser: user => {
      onChange(many ? (value || []).concat(user) : user);
    },
    value: value,
    listKey: authStrategy.listKey
  }), jsx(LinkToRelatedItems, {
    field: field,
    value: value
  })));
};

export default RelationshipField;
