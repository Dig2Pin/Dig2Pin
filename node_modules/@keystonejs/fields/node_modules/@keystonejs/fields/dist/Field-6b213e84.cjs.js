'use strict';

function _interopDefault(ex) {
  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
}

var _defineProperty = _interopDefault(require("@babel/runtime/helpers/defineProperty"));

require("@babel/runtime/helpers/objectWithoutProperties");

var core = require('@emotion/core');

var fields = require('@arch-ui/fields');

var React = require('react');

var React__default = _interopDefault(React);

require("@babel/runtime/helpers/extends");

require('@arch-ui/select');

var theme = require('@arch-ui/theme');

var reactHooks = require('@apollo/react-hooks');

var gql = _interopDefault(require('graphql-tag'));

var icons = require('@arch-ui/icons');

var button = require('@arch-ui/button');

var Tooltip = _interopDefault(require('@arch-ui/tooltip'));

require('react-select');

require('intersection-observer');

var RelationshipSelect = require('./RelationshipSelect-34cff1e7.cjs.js');

var components = require('@keystonejs/app-admin-ui/components');

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const MAX_IDS_IN_FILTER = 100;

function SetAsCurrentUser({
  listKey,
  value,
  onAddUser,
  many
}) {
  const path = 'authenticated' + listKey;
  const {
    data
  } = reactHooks.useQuery(gql`
    query User {
      ${path} {
        _label_
        id
      }
    }
  `);

  if (data && data[path]) {
    const userId = data[path].id;

    if (value !== null && (many ? value.some(item => item.id === userId) : value.id === userId)) {
      return null;
    }

    const label = `${many ? 'Add' : 'Set as'} ${data[path]._label_}`;
    return core.jsx(Tooltip, {
      placement: "top",
      content: label
    }, ref => core.jsx(button.IconButton, {
      css: {
        marginLeft: theme.gridSize
      },
      variant: "ghost",
      ref: ref,
      onClick: () => {
        onAddUser(data[path]);
      },
      icon: icons.PersonIcon,
      "aria-label": label
    }));
  }

  return null;
}

function LinkToRelatedItems({
  field,
  value
}) {
  const {
    many
  } = field.config;
  const {
    adminPath
  } = field;
  const {
    path
  } = field.getRefList();
  let isDisabled = false;
  let label;
  let link = `${adminPath}/${path}`;

  if (many) {
    label = 'View List of Related Items';

    if (!value.length) {
      isDisabled = true;
    } // What happens when there are 10,000 ids? The URL would be too
    // big, so we arbitrarily limit it to the first 100


    link = `${link}?!id_in="${value.slice(0, MAX_IDS_IN_FILTER).map(({
      id
    }) => id).join(',')}"`;
  } else {
    label = 'View Item Details';

    if (!value) {
      isDisabled = true;
    } else {
      link = `${link}/${value.id}`;
    }
  }

  return core.jsx(Tooltip, {
    placement: "top",
    content: label
  }, ref => core.jsx(button.IconButton, {
    ref: ref,
    icon: icons.LinkExternalIcon,
    "aria-label": label,
    variant: "ghost",
    css: {
      marginLeft: theme.gridSize
    },
    target: "_blank",
    to: link,
    isDisabled: isDisabled
  }));
}

function CreateAndAddItem({
  field,
  item,
  onCreate
}) {
  const {
    list,
    openCreateItemModal
  } = components.useList();
  let relatedList = field.getRefList();
  let label = `Create and add ${relatedList.singular}`;
  let prefillData;

  if (item && item.id) {
    prefillData = relatedList.fields // Find relationships on the refList which have a back link to this
    // Relationship field
    .filter(relatedField => relatedField.type === 'Relationship' && relatedField.config.ref === list.key && relatedField.config.refFieldPath === field.path) // And convert it into an object of data to prefill the form with
    .reduce((memo, prefillField) => {
      const prefill = {
        _label_: item._label_ || '<link to parent>',
        id: item.id
      };
      return _objectSpread(_objectSpread({}, memo), {}, {
        [prefillField.path]: prefillField.config.many ? [prefill] : prefill
      });
    }, {});
  }

  return core.jsx(React.Fragment, null, core.jsx(Tooltip, {
    placement: "top",
    content: label
  }, ref => {
    return core.jsx(button.IconButton, {
      ref: ref,
      onClick: openCreateItemModal,
      icon: icons.PlusIcon,
      "aria-label": label,
      variant: "ghost",
      css: {
        marginLeft: theme.gridSize
      }
    });
  }), core.jsx(components.CreateItemModal, {
    prefillData: prefillData,
    onCreate: ({
      data
    }) => {
      onCreate(data[relatedList.gqlNames.createMutationName]);
    }
  }));
}

const RelationshipField = ({
  autoFocus,
  field,
  value = [],
  renderContext,
  errors,
  onChange,
  item,
  list
}) => {
  const handleChange = option => {
    const {
      many
    } = field.config;

    if (many) {
      onChange(option ? option.map(i => i.value) : []);
    } else {
      onChange(option ? option.value : null);
    }
  };

  const {
    many,
    ref
  } = field.config;
  const {
    authStrategy
  } = field;
  const htmlID = `ks-input-${field.path}`;
  const relatedList = field.getRefList();
  return core.jsx(fields.FieldContainer, null, core.jsx(fields.FieldLabel, {
    htmlFor: htmlID,
    field: field,
    errors: errors
  }), core.jsx(fields.FieldDescription, {
    text: field.adminDoc
  }), core.jsx(fields.FieldInput, null, core.jsx("div", {
    css: {
      flex: 1
    }
  }, core.jsx(RelationshipSelect.RelationshipSelect, {
    autoFocus: autoFocus,
    isMulti: many,
    field: field,
    value: value,
    errors: errors,
    renderContext: renderContext,
    htmlID: htmlID,
    onChange: handleChange
  })), core.jsx(components.ListProvider, {
    list: relatedList
  }, core.jsx(CreateAndAddItem, {
    onCreate: item => {
      onChange(many ? value.concat(item) : item);
    },
    field: field,
    item: item,
    list: list
  })), authStrategy && ref === authStrategy.listKey && core.jsx(SetAsCurrentUser, {
    many: many,
    onAddUser: user => {
      onChange(many ? value.concat(user) : user);
    },
    value: value,
    listKey: authStrategy.listKey
  }), core.jsx(LinkToRelatedItems, {
    field: field,
    value: value
  })));
};

exports.default = RelationshipField;
