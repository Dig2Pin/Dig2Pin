import '@babel/runtime/helpers/esm/objectWithoutProperties';
import { jsx } from '@emotion/core';
import _extends from '@babel/runtime/helpers/esm/extends';
import { LinkExternalIcon, LinkIcon, CheckIcon, CircleSlashIcon } from '@arch-ui/icons';
import { gridSize, colors } from '@arch-ui/theme';
import '@arch-ui/color-utils';
import '@arch-ui/tooltip';
import '@arch-ui/typography';
import { T as ToolbarButton } from './toolbar-components-f779486c.esm.js';
import React__default, { useState, useEffect, Fragment, useContext } from 'react';
import { usePopper } from 'react-popper';
import { createPortal } from 'react-dom';
let type = 'link';

function Node({
  node,
  attributes,
  children,
  isSelected,
  editor
}) {
  const {
    data
  } = node;
  const href = data.get('href');
  const [aElement, setAElement] = useState(null);
  const [popperElement, setPopperElement] = useState(null);
  const [linkInputValue, setLinkInputValue] = useState(href); // this is terrible
  // but probably necessary
  // because if we just do editor.setNodeByKey in the input onChange
  // and let that change propagate the cursor position breaks

  useEffect(() => {
    setLinkInputValue(href);
  }, [href]);
  const {
    styles
  } = usePopper(aElement, popperElement, {
    placement: 'bottom'
  });
  return jsx(Fragment, null, jsx("a", _extends({}, attributes, {
    ref: setAElement,
    css: {
      color: 'blue',
      ':visited': {
        color: 'purple'
      }
    },
    href: href
  }), children), isSelected && createPortal(jsx("div", {
    ref: setPopperElement,
    style: styles.popper,
    css: {
      display: 'flex'
    }
  }, jsx("div", {
    css: {
      margin: gridSize,
      backgroundColor: colors.N90,
      color: 'white',
      padding: 8,
      borderRadius: 6,
      display: 'flex'
    }
  }, jsx(LinkInput, {
    value: linkInputValue,
    onChange: event => {
      setLinkInputValue(event.target.value);
      editor.setNodeByKey(node.key, {
        data: data.set('href', event.target.value)
      });
    }
  }), jsx(ToolbarButton, {
    as: "a",
    tooltipPlacement: "bottom",
    icon: jsx(LinkExternalIcon, null),
    target: "_blank",
    rel: "noopener",
    label: "Open Link",
    css: {
      marginLeft: gridSize
    },
    href: href
  }))), document.body));
}

function LinkInput(props) {
  return jsx("input", _extends({
    placeholder: "Link...",
    css: {
      border: 0,
      outline: 'none',
      background: 'transparent',
      color: 'white'
    }
  }, props));
}

let SetLinkRange = React__default.createContext(() => {});

let LinkMenu = props => {
  let [value, setValue] = useState('');
  return jsx("form", {
    onSubmit: e => {
      e.stopPropagation();
      e.preventDefault();
      props.onSubmit(value);
    },
    css: {
      display: 'flex'
    }
  }, jsx(LinkInput, {
    autoFocus: true,
    value: value,
    onChange: e => {
      setValue(e.target.value);
    }
  }), jsx(ToolbarButton, {
    label: "Submit",
    icon: jsx(CheckIcon, null),
    type: "submit"
  }), jsx(ToolbarButton, {
    label: "Cancel",
    icon: jsx(CircleSlashIcon, null),
    onClick: () => {
      props.onCancel();
    }
  }));
};

function Toolbar({
  children,
  editor
}) {
  let [linkRange, setLinkRange] = useState(null);
  return jsx(SetLinkRange.Provider, {
    value: setLinkRange
  }, linkRange === null ? children : jsx(LinkMenu, {
    onSubmit: value => {
      editor.wrapInlineAtRange(linkRange, {
        type: type,
        data: {
          href: value
        }
      });
      editor.deselect();
    },
    onCancel: () => {
      setLinkRange(null);
    }
  }));
}

function ToolbarElement({
  editor,
  editorState
}) {
  let hasLinks = editorState.inlines.some(inline => inline.type === type);
  let setLinkRange = useContext(SetLinkRange);
  return jsx(ToolbarButton, {
    isActive: hasLinks,
    label: hasLinks ? 'Remove Link' : 'Link',
    icon: jsx(LinkIcon, null),
    onClick: () => {
      if (hasLinks) {
        editor.unwrapInline(type);
      } else {
        setLinkRange(editorState.selection);
      }
    }
  });
}

export { Node, Toolbar, ToolbarElement, type };
