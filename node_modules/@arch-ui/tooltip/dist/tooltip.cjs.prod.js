"use strict";

function _interopDefault(ex) {
  return ex && "object" == typeof ex && "default" in ex ? ex.default : ex;
}

Object.defineProperty(exports, "__esModule", {
  value: !0
});

var _defineProperty = _interopDefault(require("@babel/runtime/helpers/defineProperty")), core = require("@emotion/core"), react = require("react"), reactDom = require("react-dom"), flushable = _interopDefault(require("flushable")), styled = _interopDefault(require("@emotion/styled")), reactPopper = require("react-popper"), modalUtils = require("@arch-ui/modal-utils"), theme = require("@arch-ui/theme");

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

const TooltipElement = styled.div({
  backgroundColor: theme.colors.N80,
  borderRadius: 3,
  color: "white",
  fontSize: "0.75rem",
  fontWeight: 500,
  padding: "".concat(theme.gridSize / 2, "px ").concat(theme.gridSize, "px"),
  pointerEvents: "none",
  zIndex: 2
}), TooltipPositioner = ({targetNode: targetNode, placement: placement, style: style, className: className, children: children}) => {
  const [popperElement, setPopperElement] = react.useState(null), {styles: styles} = reactPopper.usePopper(targetNode, popperElement, {
    placement: placement,
    modifiers: [ {
      name: "hide",
      enabled: !1
    }, {
      name: "preventOverflow",
      enabled: !1
    } ]
  });
  return reactDom.createPortal(core.jsx("div", {
    ref: setPopperElement,
    css: {
      zIndex: 2e3
    },
    style: _objectSpread({}, style, {}, styles.popper)
  }, core.jsx("div", {
    css: {
      margin: theme.gridSize
    }
  }, core.jsx(TooltipElement, {
    className: className
  }, children))), document.body);
}, LISTENER_OPTIONS = {
  passive: !0
};

let pendingHide;

const showTooltip = (fn, defaultDelay) => {
  const isHidePending = pendingHide && pendingHide.pending();
  return isHidePending && pendingHide.flush(), flushable(fn, isHidePending ? 0 : defaultDelay).cancel;
}, hideTooltip = (fn, defaultDelay) => (pendingHide = flushable(fn, defaultDelay)).cancel, Tooltip = ({children: children, content: content, onHide: onHide, onShow: onShow, placement: placement = "bottom", className: className, hideOnMouseDown: hideOnMouseDown, hideOnKeyDown: hideOnKeyDown, delay: delay = 300}) => {
  const [isVisible, setIsVisible] = react.useState(!1), ref = react.useRef();
  return react.useEffect(() => {
    const target = ref.current;
    if (!target) throw new Error("You must pass the ref onto your target node.");
    if (!target.nodeName) throw new Error("It looks like you've passed the ref onto a component. You must pass the ref onto your target node.");
    let cancelPendingSetState = () => {};
    const cancel = () => {
      cancelPendingSetState(), setIsVisible(!1);
    }, handleMouseEnter = () => {
      cancelPendingSetState(), isVisible || (hideOnMouseDown && target && target.addEventListener("mousedown", cancel, LISTENER_OPTIONS), 
      hideOnKeyDown && document.addEventListener("keydown", cancel, LISTENER_OPTIONS), 
      cancelPendingSetState = showTooltip(() => setIsVisible(!0), delay));
    }, handleMouseLeave = () => {
      cancelPendingSetState(), isVisible && (hideOnMouseDown && target && target.removeEventListener("mousedown", cancel, LISTENER_OPTIONS), 
      hideOnKeyDown && document.removeEventListener("keydown", cancel, LISTENER_OPTIONS), 
      cancelPendingSetState = hideTooltip(() => setIsVisible(!1), delay));
    };
    return target.addEventListener("mouseenter", handleMouseEnter, LISTENER_OPTIONS), 
    target.addEventListener("mouseleave", handleMouseLeave, LISTENER_OPTIONS), () => {
      cancelPendingSetState(), target && (target.removeEventListener("mouseenter", handleMouseEnter, LISTENER_OPTIONS), 
      target.removeEventListener("mouseleave", handleMouseLeave, LISTENER_OPTIONS));
    };
  }, [ isVisible ]), core.jsx(react.Fragment, null, children(ref), core.jsx(modalUtils.TransitionProvider, {
    isOpen: isVisible,
    onEntered: onShow,
    onExited: onHide
  }, transitionState => core.jsx(TooltipPositioner, {
    targetNode: ref.current,
    placement: placement,
    className: className,
    style: modalUtils.fade(transitionState)
  }, content)));
};

exports.default = Tooltip;
