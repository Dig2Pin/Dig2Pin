"use strict";

function validateHex(color) {
  const hex = color.replace("#", "");
  if (3 === hex.length) return hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
  if (6 !== hex.length) throw new Error('Invalid color value provided: "'.concat(color, '"'));
  return hex;
}

function hexToRgb(hex) {
  return {
    r: parseInt(hex.substring(0, 2), 16),
    g: parseInt(hex.substring(2, 4), 16),
    b: parseInt(hex.substring(4, 6), 16)
  };
}

function stringToRGB(color) {
  const tuple = color.substring(4, color.length - 1).replace(/ /g, "").split(",");
  return {
    r: parseInt(tuple[0], 10),
    g: parseInt(tuple[1], 10),
    b: parseInt(tuple[2], 10)
  };
}

function anyToRGB(color) {
  if (color.length > 7) return stringToRGB(color);
  return hexToRgb(validateHex(color));
}

function toRgbString({r: r, g: g, b: b, a: a}) {
  return a ? "rgba(".concat([ r, g, b, a ].join(","), ")") : "rgb(".concat([ r, g, b ].join(","), ")");
}

function alpha(color, opacity = 1) {
  const {r: r, g: g, b: b} = anyToRGB(color);
  return toRgbString({
    r: r,
    g: g,
    b: b,
    a: opacity
  });
}

Object.defineProperty(exports, "__esModule", {
  value: !0
});

const shader = (c, t, p) => Math.round((t - c) * p) + c;

function shade(color, percent) {
  const df = percent / 100, {r: r, g: g, b: b} = anyToRGB(color), t = df < 0 ? 0 : 255, p = Math.abs(df);
  return toRgbString({
    r: shader(r, t, p),
    g: shader(g, t, p),
    b: shader(b, t, p)
  });
}

const lighten = shade;

function darken(color, percent) {
  return shade(color, -1 * percent);
}

const mixer = (c1, c2, df) => Math.round((c2 - c1) * df) + c1;

function mix(color1, color2, percent) {
  const df = percent / 100, {r: r1, g: g1, b: b1} = anyToRGB(color1), {r: r2, g: g2, b: b2} = anyToRGB(color2);
  return toRgbString({
    r: mixer(r1, r2, df),
    g: mixer(g1, g2, df),
    b: mixer(b1, b2, df)
  });
}

exports.alpha = alpha, exports.darken = darken, exports.lighten = lighten, exports.mix = mix;
